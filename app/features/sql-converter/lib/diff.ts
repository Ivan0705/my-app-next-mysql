import { SQLDifference } from "../model/types";

// Карта конвертаций типов данных между диалектами
const DATA_TYPE_CONVERSIONS: Record<string, Record<string, string>> = {
  // MySQL -> другие диалекты
  "mysql:postgres": {
    AUTO_INCREMENT: "GENERATED BY DEFAULT AS IDENTITY",
    INT: "INTEGER",
    INTEGER: "INTEGER",
    TIMESTAMP: "TIMESTAMPTZ",
    TINYINT: "SMALLINT",
    MEDIUMINT: "INTEGER",
    DATETIME: "TIMESTAMP",
    YEAR: "INTEGER",
    ENUM: "VARCHAR", // В PostgreSQL лучше использовать VARCHAR с CHECK
    SET: "VARCHAR[]", // В PostgreSQL массив строк
    TINYTEXT: "VARCHAR(255)",
    MEDIUMTEXT: "TEXT",
    LONGTEXT: "TEXT",
    TINYBLOB: "BYTEA",
    MEDIUMBLOB: "BYTEA",
    LONGBLOB: "BYTEA",
  },
  "mysql:snowflake": {
    AUTO_INCREMENT: "AUTOINCREMENT",
    INT: "INTEGER",
    INTEGER: "INTEGER",
    DECIMAL: "NUMBER",
    NUMERIC: "NUMBER",
    DATETIME: "TIMESTAMP_NTZ",
    TIMESTAMP: "TIMESTAMP_NTZ",
    TINYINT: "INTEGER",
    SMALLINT: "INTEGER",
    MEDIUMINT: "INTEGER",
    BIGINT: "INTEGER",
    FLOAT: "FLOAT",
    DOUBLE: "DOUBLE",
    TEXT: "VARCHAR",
    MEDIUMTEXT: "VARCHAR",
    LONGTEXT: "VARCHAR",
    BLOB: "BINARY",
  },
  "mysql:bigquery": {
    AUTO_INCREMENT: "",
    INT: "INT64",
    INTEGER: "INT64",
    BIGINT: "INT64",
    FLOAT: "FLOAT64",
    DOUBLE: "FLOAT64",
    DECIMAL: "NUMERIC",
    NUMERIC: "NUMERIC",
    DATETIME: "DATETIME",
    TIMESTAMP: "TIMESTAMP",
    VARCHAR: "STRING",
    CHAR: "STRING",
    TEXT: "STRING",
    BLOB: "BYTES",
    JSON: "JSON",
  },
  "mysql:oracle": {
    AUTO_INCREMENT: "",
    INT: "NUMBER",
    INTEGER: "NUMBER",
    DECIMAL: "NUMBER",
    NUMERIC: "NUMBER",
    FLOAT: "BINARY_FLOAT",
    DOUBLE: "BINARY_DOUBLE",
    VARCHAR: "VARCHAR2",
    TEXT: "CLOB",
    DATETIME: "TIMESTAMP",
    TIMESTAMP: "TIMESTAMP",
    BLOB: "BLOB",
  },
  "mysql:mssql": {
    AUTO_INCREMENT: "IDENTITY(1,1)",
    INT: "INT",
    DATETIME: "DATETIME2",
    TIMESTAMP: "DATETIME2",
    TEXT: "NVARCHAR(MAX)",
    BLOB: "VARBINARY(MAX)",
    ENUM: "VARCHAR", // SQL Server не имеет ENUM
    SET: "VARCHAR", // SQL Server не имеет SET
  },
  "mysql:sqlite": {
    AUTO_INCREMENT: "AUTOINCREMENT",
    INT: "INTEGER",
    INTEGER: "INTEGER",
    DATETIME: "TEXT", // SQLite хранит даты как текст
    TIMESTAMP: "TEXT",
    DECIMAL: "NUMERIC",
    VARCHAR: "TEXT",
    CHAR: "TEXT",
    TEXT: "TEXT",
    BLOB: "BLOB",
  },
  "mysql:redshift": {
    AUTO_INCREMENT: "IDENTITY(1,1)",
    INT: "INTEGER",
    INTEGER: "INTEGER",
    DATETIME: "TIMESTAMP",
    TIMESTAMP: "TIMESTAMP",
    DECIMAL: "NUMERIC",
    TEXT: "VARCHAR(MAX)",
    BLOB: "VARBYTE",
    ENUM: "VARCHAR", // Redshift не имеет ENUM
    JSON: "SUPER", // Redshift использует SUPER для JSON
  },
};

// Диалект-специфичные ключевые слова (которые не являются типами данных)
const DIALECT_SPECIFIC_KEYWORDS: Record<string, string[]> = {
  mysql: [
    "ENGINE",
    "CHARSET",
    "COLLATE",
    "DELIMITER",
    "UNSIGNED",
    "ZEROFILL",
    "STORED",
    "VIRTUAL",
  ],
  postgres: [
    "SERIAL",
    "BIGSERIAL",
    "$$",
    "BYTEA",
    "JSONB",
    "UUID",
    "TIMESTAMPTZ",
    "INTERVAL",
    "MONEY",
    "INHERITS",
    "OIDS",
    "TIMESTAMPTZ",
  ],
  oracle: [
    "VARCHAR2",
    "NVARCHAR2",
    "NCLOB",
    "BFILE",
    "RAW",
    "LONG",
    "ROWID",
    "UROWID",
    "SYSDATE",
    "SYSTIMESTAMP",
  ],
  snowflake: [
    "VARIANT",
    "OBJECT",
    "ARRAY",
    "TIMESTAMP_NTZ",
    "TIMESTAMP_LTZ",
    "TIMESTAMP_TZ",
    "CLUSTER BY",
    "STAGE",
    "PIPE",
    "STREAM",
    "TASK",
  ],
  mssql: [
    "GO",
    "NVARCHAR",
    "VARBINARY",
    "UNIQUEIDENTIFIER",
    "HIERARCHYID",
    "FILESTREAM",
    "ROWGUIDCOL",
  ],
  sqlite: ["ROWID", "VIRTUAL", "STRICT"],
  bigquery: [
    "INT64",
    "FLOAT64",
    "STRING",
    "BYTES",
    "ARRAY",
    "STRUCT",
    "GEOGRAPHY",
    "BIGNUMERIC",
  ],
  redshift: [
    "SUPER",
    "VARBYTE",
    "TIMESTAMPTZ",
    "GEOMETRY",
    "HLLSKETCH",
    "COMPOUND SORTKEY",
    "INTERLEAVED SORTKEY",
  ],
};

// Главная функция для поиска различий
export const findSQLDifferences = (
  original: string,
  converted: string,
  fromDialect: string,
  toDialect: string
): SQLDifference[] => {
  const differences: SQLDifference[] = [];

  const originalLines = original.split("\n");
  const convertedLines = converted.split("\n");

  // Получаем карту конвертаций
  const conversionKey = `${fromDialect}:${toDialect}`;
  const typeConversions = DATA_TYPE_CONVERSIONS[conversionKey] || {};
  const fromSpecificKeywords = DIALECT_SPECIFIC_KEYWORDS[fromDialect] || [];
  const toSpecificKeywords = DIALECT_SPECIFIC_KEYWORDS[toDialect] || [];

  // Создаем расширенную карту для поиска
  const extendedTypeMap = createExtendedTypeMap(
    typeConversions,
    fromDialect,
    toDialect
  );

  // 1. Поиск изменений типов данных и ключевых слов с конвертацией
  findDataTypeChanges(
    originalLines,
    convertedLines,
    fromDialect,
    toDialect,
    typeConversions,
    extendedTypeMap,
    differences
  );

  // 2. Поиск диалект-специфичных ключевых слов (без конвертации)
  findDialectSpecificKeywords(
    originalLines,
    convertedLines,
    fromDialect,
    toDialect,
    fromSpecificKeywords,
    toSpecificKeywords,
    differences
  );

  // 3. Специальные случаи для конкретных диалектов
  findSpecialCases(
    originalLines,
    convertedLines,
    fromDialect,
    toDialect,
    differences
  );

  // 4. Поиск добавленных комментариев
  findAddedComments(
    originalLines,
    convertedLines,
    fromDialect,
    toDialect,
    differences
  );

  // 5. Поиск изменений в синтаксисе функций
  findFunctionChanges(
    originalLines,
    convertedLines,
    fromDialect,
    toDialect,
    differences
  );

  // 6. Специальный поиск для Snowflake
  if (fromDialect === "mysql" && toDialect === "snowflake") {
    findSnowflakeSpecificChanges(originalLines, convertedLines, differences);
  }

  // 7. Специальный поиск для Oracle
  if (fromDialect === "mysql" && toDialect === "oracle") {
    findOracleSpecificChanges(originalLines, convertedLines, differences);
  }

  // 7. Специальный поиск для SQLite
  if (fromDialect === "mysql" && toDialect === "sqlite") {
    findSQLiteSpecificChanges(originalLines, convertedLines, differences);
  }

  // 8. Специальный поиск для Redshift
  if (fromDialect === "mysql" && toDialect === "redshift") {
    findRedshiftSpecificChanges(originalLines, convertedLines, differences);
  }
  // 9. Специальный поиск для SnowFlake
  if (fromDialect === "mysql" && toDialect === "snowflake") {
    console.log(`=== DEBUG: Snowflake Conversion ===`);
    console.log(`AUTO_INCREMENT -> ${typeConversions["AUTO_INCREMENT"]}`);
    console.log(`INT -> ${typeConversions["INT"]}`);
    console.log(`DECIMAL -> ${typeConversions["DECIMAL"]}`);

    // Поиск AUTO_INCREMENT в оригинале
    originalLines.forEach((line, index) => {
      if (line.includes("AUTO_INCREMENT")) {
        console.log(`Found AUTO_INCREMENT at line ${index + 1}: ${line}`);
      }
      if (line.includes("INT")) {
        console.log(`Found INT at line ${index + 1}: ${line}`);
      }
    });
  }

  // 10. Специальный поиск для MSSQL
  if (fromDialect === "mysql" && toDialect === "mssql") {
    findMSSQLSpecificChanges(originalLines, convertedLines, differences);
  }
  // 11. Специальный поиск для POSTGRESQL
  if (fromDialect === "mysql" && toDialect === "postgres") {
    findPostgresSpecificChanges(originalLines, convertedLines, differences);
  }
  return filterDuplicates(differences);
};

const findPostgresSpecificChanges = (
  originalLines: string[],
  convertedLines: string[],
  differences: SQLDifference[]
) => {
  console.log("=== DEBUG: findPostgresSpecificChanges ===");

  originalLines.forEach((line, lineIndex) => {
    console.log(`Original line ${lineIndex + 1}: ${line}`);

    // Поиск INT
    const intRegex = /\bINT\b/gi;
    let match: RegExpExecArray | null;

    while ((match = intRegex.exec(line)) !== null) {
      const position = match.index;
      console.log(`  Found INT at position ${position}`);

      if (isDataTypeInContext(line, position, "INT")) {
        console.log(`  INT is in correct context`);

        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const pgLine = convertedLines[i];
          console.log(`  Checking converted line ${i + 1}: ${pgLine}`);

          const integerRegex = /\bINTEGER\b/gi;
          const integerMatch = integerRegex.exec(pgLine);

          if (integerMatch) {
            console.log(`  Found INTEGER at position ${integerMatch.index}`);
            differences.push({
              type: "datatype",
              originalWord: "INT",
              convertedWord: "INTEGER",
              description: "INT converted to INTEGER (MySQL → PostgreSQL)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: integerMatch.index,
              equivalent: "INTEGER",
            });
            break;
          }
        }
      }
    }
  });
};

const findMSSQLSpecificChanges = (
  originalLines: string[],
  convertedLines: string[],
  differences: SQLDifference[]
) => {
  originalLines.forEach((line, lineIndex) => {
    // Поиск INT -> INT (остается тем же в MSSQL)
    const intRegex = /\bINT\b/gi;
    let match: RegExpExecArray | null;

    while ((match = intRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "INT")) {
        // В MSSQL INT остается INT, но проверяем
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const mssqlLine = convertedLines[i];
          const mssqlIntRegex = /\bINT\b/gi;
          const mssqlMatch = mssqlIntRegex.exec(mssqlLine);

          if (mssqlMatch) {
            // INT -> INT (без изменений)
            differences.push({
              type: "datatype",
              originalWord: "INT",
              convertedWord: "INT",
              description: "Integer type (MySQL → SQL Server)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: mssqlMatch.index,
              equivalent: "INT",
            });
            break;
          }
        }
      }
    }

    // Поиск VARCHAR -> VARCHAR/NVARCHAR
    const varcharRegex = /\bVARCHAR\b/gi;
    while ((match = varcharRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "VARCHAR")) {
        // Ищем VARCHAR или NVARCHAR в MSSQL
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const mssqlLine = convertedLines[i];
          const mssqlVarcharRegex = /\b(VARCHAR|NVARCHAR)\b/gi;
          const mssqlMatch = mssqlVarcharRegex.exec(mssqlLine);

          if (mssqlMatch) {
            differences.push({
              type: "datatype",
              originalWord: "VARCHAR",
              convertedWord: mssqlMatch[0],
              description: "String type (MySQL → SQL Server)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: mssqlMatch.index,
              equivalent: mssqlMatch[0],
            });
            break;
          }
        }
      }
    }

    // Поиск DECIMAL -> DECIMAL/NUMERIC
    const decimalRegex = /\bDECIMAL\b/gi;
    while ((match = decimalRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "DECIMAL")) {
        // Ищем DECIMAL или NUMERIC в MSSQL
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const mssqlLine = convertedLines[i];
          const mssqlDecimalRegex = /\b(DECIMAL|NUMERIC)\b/gi;
          const mssqlMatch = mssqlDecimalRegex.exec(mssqlLine);

          if (mssqlMatch) {
            differences.push({
              type: "datatype",
              originalWord: "DECIMAL",
              convertedWord: mssqlMatch[0],
              description: "Decimal type (MySQL → SQL Server)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: mssqlMatch.index,
              equivalent: mssqlMatch[0],
            });
            break;
          }
        }
      }
    }
  });
};

const findSnowflakeSpecificChanges = (
  originalLines: string[],
  convertedLines: string[],
  differences: SQLDifference[]
) => {
  originalLines.forEach((line, lineIndex) => {
    // Поиск AUTO_INCREMENT -> AUTOINCREMENT
    const autoIncRegex = /\bAUTO_INCREMENT\b/gi;
    let match: RegExpExecArray | null;

    while ((match = autoIncRegex.exec(line)) !== null) {
      const position = match.index;
      const before = line.substring(0, position);

      // Проверяем контекст (после типа данных)
      if (
        /\b(INT|INTEGER|BIGINT|SMALLINT|TINYINT|MEDIUMINT|NUMBER)\s+$/i.test(
          before
        )
      ) {
        // Ищем AUTOINCREMENT в Snowflake
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const sfLine = convertedLines[i];
          const autoincrementRegex = /\bAUTOINCREMENT\b/gi;
          const autoincrementMatch = autoincrementRegex.exec(sfLine);

          if (autoincrementMatch) {
            differences.push({
              type: "keyword",
              originalWord: "AUTO_INCREMENT",
              convertedWord: "AUTOINCREMENT",
              description: "Auto-increment (MySQL → Snowflake)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: autoincrementMatch.index,
              equivalent: "AUTOINCREMENT",
            });
            break;
          }
        }
      }
    }

    // Поиск INT -> INTEGER
    const intRegex = /\bINT\b/gi;
    while ((match = intRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "INT")) {
        // Ищем INTEGER в Snowflake
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const sfLine = convertedLines[i];
          const integerRegex = /\bINTEGER\b/gi;
          const integerMatch = integerRegex.exec(sfLine);

          if (integerMatch) {
            differences.push({
              type: "datatype",
              originalWord: "INT",
              convertedWord: "INTEGER",
              description: "INT converted to INTEGER (MySQL → Snowflake)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: integerMatch.index,
              equivalent: "INTEGER",
            });
            break;
          }
        }
      }
    }

    // Поиск DECIMAL -> NUMBER (включая параметры)
    const decimalRegex = /\bDECIMAL(\s*\(\s*\d+\s*(,\s*\d+\s*)?\))?\b/gi;
    while ((match = decimalRegex.exec(line)) !== null) {
      const position = match.index;
      const matchedText = match[0];

      if (isDataTypeInContext(line, position, matchedText)) {
        // Ищем NUMBER в Snowflake
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const sfLine = convertedLines[i];
          const numberRegex = /\bNUMBER(\s*\(\s*\d+\s*(,\s*\d+\s*)?\))?\b/gi;
          const numberMatch = numberRegex.exec(sfLine);

          if (numberMatch) {
            differences.push({
              type: "datatype",
              originalWord: matchedText,
              convertedWord: numberMatch[0],
              description:
                "Decimal type converted to NUMBER (MySQL → Snowflake)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: numberMatch.index,
              equivalent: numberMatch[0],
            });
            break;
          }
        }
      }
    }

    // Поиск NUMERIC -> NUMBER
    const numericRegex = /\bNUMERIC(\s*\(\s*\d+\s*(,\s*\d+\s*)?\))?\b/gi;
    while ((match = numericRegex.exec(line)) !== null) {
      const position = match.index;
      const matchedText = match[0];

      if (isDataTypeInContext(line, position, matchedText)) {
        // Ищем NUMBER в Snowflake
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const sfLine = convertedLines[i];
          const numberRegex = /\bNUMBER(\s*\(\s*\d+\s*(,\s*\d+\s*)?\))?\b/gi;
          const numberMatch = numberRegex.exec(sfLine);

          if (numberMatch) {
            differences.push({
              type: "datatype",
              originalWord: matchedText,
              convertedWord: numberMatch[0],
              description:
                "Numeric type converted to NUMBER (MySQL → Snowflake)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: numberMatch.index,
              equivalent: numberMatch[0],
            });
            break;
          }
        }
      }
    }

    // Поиск DATETIME/TIMESTAMP -> TIMESTAMP_NTZ
    const datetimeRegex = /\b(DATETIME|TIMESTAMP)\b/gi;
    while ((match = datetimeRegex.exec(line)) !== null) {
      const position = match.index;
      const originalType = match[0];

      if (isDataTypeInContext(line, position, originalType)) {
        // Ищем TIMESTAMP_NTZ в Snowflake
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const sfLine = convertedLines[i];
          const timestampRegex = /\bTIMESTAMP_NTZ\b/gi;
          const timestampMatch = timestampRegex.exec(sfLine);

          if (timestampMatch) {
            differences.push({
              type: "datatype",
              originalWord: originalType,
              convertedWord: "TIMESTAMP_NTZ",
              description: `${originalType} converted to TIMESTAMP_NTZ (MySQL → Snowflake)`,
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: timestampMatch.index,
              equivalent: "TIMESTAMP_NTZ",
            });
            break;
          }
        }
      }
    }
  });
};

const findRedshiftSpecificChanges = (
  originalLines: string[],
  convertedLines: string[],
  differences: SQLDifference[]
) => {
  originalLines.forEach((line, lineIndex) => {
    // Поиск INT -> INTEGER
    const intRegex = /\bINT\b/gi;
    let match: RegExpExecArray | null;

    while ((match = intRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "INT")) {
        // Ищем INTEGER в Redshift
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const rsLine = convertedLines[i];
          const integerRegex = /\bINTEGER\b/gi;
          const integerMatch = integerRegex.exec(rsLine);

          if (integerMatch) {
            differences.push({
              type: "datatype",
              originalWord: "INT",
              convertedWord: "INTEGER",
              description: "Integer type converted (MySQL → Redshift)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: integerMatch.index,
              equivalent: "INTEGER",
            });
            break;
          }
        }
      }
    }

    // Поиск TEXT -> VARCHAR(MAX)
    const textRegex = /\bTEXT\b/gi;
    while ((match = textRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "TEXT")) {
        // Ищем VARCHAR(MAX) в Redshift
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const rsLine = convertedLines[i];
          const varcharRegex = /\bVARCHAR\s*\(\s*MAX\s*\)/gi;
          const varcharMatch = varcharRegex.exec(rsLine);

          if (varcharMatch) {
            differences.push({
              type: "datatype",
              originalWord: "TEXT",
              convertedWord: "VARCHAR(MAX)",
              description:
                "Text type converted to VARCHAR(MAX) (MySQL → Redshift)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: varcharMatch.index,
              equivalent: "VARCHAR(MAX)",
            });
            break;
          }
        }
      }
    }

    // Поиск DECIMAL -> NUMERIC
    const decimalRegex = /\bDECIMAL\b/gi;
    while ((match = decimalRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "DECIMAL")) {
        // Ищем NUMERIC в Redshift
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const rsLine = convertedLines[i];
          const numericRegex = /\bNUMERIC\b/gi;
          const numericMatch = numericRegex.exec(rsLine);

          if (numericMatch) {
            differences.push({
              type: "datatype",
              originalWord: "DECIMAL",
              convertedWord: "NUMERIC",
              description:
                "Decimal type converted to NUMERIC (MySQL → Redshift)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: numericMatch.index,
              equivalent: "NUMERIC",
            });
            break;
          }
        }
      }
    }
  });
};

const findOracleSpecificChanges = (
  originalLines: string[],
  convertedLines: string[],
  differences: SQLDifference[]
) => {
  originalLines.forEach((line, lineIndex) => {
    // Поиск INT -> NUMBER
    const intRegex = /\bINT\b/gi;
    let match: RegExpExecArray | null;

    while ((match = intRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "INT")) {
        // Ищем NUMBER в Oracle
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const oracleLine = convertedLines[i];
          const numberRegex = /\bNUMBER\b/gi;
          const numberMatch = numberRegex.exec(oracleLine);

          if (numberMatch) {
            differences.push({
              type: "datatype",
              originalWord: "INT",
              convertedWord: "NUMBER",
              description: "Integer type converted to NUMBER (MySQL → Oracle)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: numberMatch.index,
              equivalent: "NUMBER",
            });
            break;
          }
        }
      }
    }

    // Поиск VARCHAR -> VARCHAR2
    const varcharRegex = /\bVARCHAR\b/gi;
    while ((match = varcharRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "VARCHAR")) {
        // Ищем VARCHAR2 в Oracle
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const oracleLine = convertedLines[i];
          const varchar2Regex = /\bVARCHAR2\b/gi;
          const varchar2Match = varchar2Regex.exec(oracleLine);

          if (varchar2Match) {
            differences.push({
              type: "datatype",
              originalWord: "VARCHAR",
              convertedWord: "VARCHAR2",
              description: "String type (MySQL → Oracle)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: varchar2Match.index,
              equivalent: "VARCHAR2",
            });
            break;
          }
        }
      }
    }

    // Поиск TEXT -> CLOB
    const textRegex = /\bTEXT\b/gi;
    while ((match = textRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "TEXT")) {
        // Ищем CLOB в Oracle
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const oracleLine = convertedLines[i];
          const clobRegex = /\bCLOB\b/gi;
          const clobMatch = clobRegex.exec(oracleLine);

          if (clobMatch) {
            differences.push({
              type: "datatype",
              originalWord: "TEXT",
              convertedWord: "CLOB",
              description: "Text type converted to CLOB (MySQL → Oracle)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: clobMatch.index,
              equivalent: "CLOB",
            });
            break;
          }
        }
      }
    }
  });
};

const findSQLiteSpecificChanges = (
  originalLines: string[],
  convertedLines: string[],
  differences: SQLDifference[]
) => {
  originalLines.forEach((line, lineIndex) => {
    // Поиск DECIMAL -> NUMERIC
    const decimalRegex = /\bDECIMAL\b/gi;
    let match: RegExpExecArray | null;

    while ((match = decimalRegex.exec(line)) !== null) {
      const position = match.index;

      if (isDataTypeInContext(line, position, "DECIMAL")) {
        // Ищем NUMERIC в SQLite
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const sqliteLine = convertedLines[i];
          const numericRegex = /\bNUMERIC\b/gi;
          const numericMatch = numericRegex.exec(sqliteLine);

          if (numericMatch) {
            differences.push({
              type: "datatype",
              originalWord: "DECIMAL",
              convertedWord: "NUMERIC",
              description: "Decimal type (MySQL → SQLite)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: numericMatch.index,
              equivalent: "NUMERIC",
            });
            break;
          }
        }
      }
    }
  });
};

const findDialectSpecificKeywords = (
  originalLines: string[],
  convertedLines: string[],
  fromDialect: string,
  toDialect: string,
  fromSpecificKeywords: string[],
  toSpecificKeywords: string[],
  differences: SQLDifference[]
) => {
  // Ищем ключевые слова исходного диалекта
  originalLines.forEach((line, lineIndex) => {
    fromSpecificKeywords.forEach((keyword) => {
      const regex = new RegExp(`\\b${keyword}\\b`, "gi");
      const match = regex.exec(line);
      if (match) {
        // Проверяем, не было ли это слово уже обработано как тип данных
        const isAlreadyProcessed = differences.some(
          (diff) =>
            diff.originalLine === lineIndex && diff.originalWord === keyword
        );

        if (!isAlreadyProcessed) {
          differences.push({
            type: "keyword",
            originalWord: keyword,
            convertedWord: "",
            description: `${fromDialect}-specific keyword (may not exist in ${toDialect})`,
            originalLine: lineIndex,
            originalPosition: match.index,
            convertedLine: -1,
            convertedPosition: -1,
            equivalent: "",
          });
        }
      }
    });
  });

  // Ищем ключевые слова целевого диалекта
  convertedLines.forEach((line, lineIndex) => {
    toSpecificKeywords.forEach((keyword) => {
      const regex = new RegExp(`\\b${keyword}\\b`, "gi");
      const match = regex.exec(line);
      if (match) {
        // Проверяем, не было ли это слово уже обработано как тип данных
        const isAlreadyProcessed = differences.some(
          (diff) =>
            diff.convertedLine === lineIndex && diff.convertedWord === keyword
        );

        if (!isAlreadyProcessed) {
          differences.push({
            type: "keyword",
            originalWord: "",
            convertedWord: keyword,
            description: `${toDialect}-specific keyword (added during conversion)`,
            originalLine: -1,
            originalPosition: -1,
            convertedLine: lineIndex,
            convertedPosition: match.index,
            equivalent: "",
          });
        }
      }
    });
  });
};

// Новая функция для создания расширенной карты типов
const createExtendedTypeMap = (
  typeConversions: Record<string, string>,
  fromDialect: string,
  toDialect: string
): Record<string, string[]> => {
  const extendedMap: Record<string, string[]> = {};

  // Базовые маппинги для MySQL -> PostgreSQL
  if (fromDialect === "mysql" && toDialect === "postgres") {
    extendedMap["TIMESTAMP"] = ["TIMESTAMPTZ", "TIMESTAMP"];
    extendedMap["INT"] = ["INTEGER", "INT"]; // INT может стать INTEGER
    extendedMap["INTEGER"] = ["INTEGER", "INT"]; // INTEGER может остаться INTEGER
    extendedMap["DATETIME"] = ["TIMESTAMP", "TIMESTAMPTZ"];
    extendedMap["TINYINT"] = ["SMALLINT", "INTEGER"];
    extendedMap["MEDIUMINT"] = ["INTEGER"];
    extendedMap["SERIAL"] = ["GENERATED BY DEFAULT AS IDENTITY", "SERIAL"];
    extendedMap["AUTO_INCREMENT"] = ["GENERATED BY DEFAULT AS IDENTITY"];

    // Добавляем специальные случаи
    extendedMap["TIMESTAMPTZ"] = ["TIMESTAMPTZ", "TIMESTAMP"];
  }

  // Базовые маппинги для MySQL -> Snowflake
  if (fromDialect === "mysql" && toDialect === "snowflake") {
    extendedMap["INT"] = ["INTEGER", "NUMBER", "INT"];
    extendedMap["INTEGER"] = ["INTEGER", "NUMBER", "INT"];
    extendedMap["DECIMAL"] = ["NUMBER", "DECIMAL"];
    extendedMap["NUMERIC"] = ["NUMBER", "NUMERIC"];
    extendedMap["DATETIME"] = ["TIMESTAMP_NTZ", "TIMESTAMP", "DATETIME"];
    extendedMap["TIMESTAMP"] = ["TIMESTAMP_NTZ", "TIMESTAMP"];
    extendedMap["AUTO_INCREMENT"] = ["AUTOINCREMENT", "IDENTITY"];
    extendedMap["TEXT"] = ["VARCHAR", "STRING", "TEXT"];
    extendedMap["MEDIUMTEXT"] = ["VARCHAR", "STRING"];
    extendedMap["LONGTEXT"] = ["VARCHAR", "STRING"];
    extendedMap["BLOB"] = ["BINARY", "VARBINARY"];
    extendedMap["TINYINT"] = ["INTEGER", "NUMBER"];
    extendedMap["SMALLINT"] = ["INTEGER", "NUMBER"];
    extendedMap["MEDIUMINT"] = ["INTEGER", "NUMBER"];
    extendedMap["BIGINT"] = ["INTEGER", "NUMBER"];
    extendedMap["FLOAT"] = ["FLOAT", "REAL"];
    extendedMap["DOUBLE"] = ["DOUBLE", "FLOAT"];
  }

  // Базовые маппинги для MySQL -> Oracle
  if (fromDialect === "mysql" && toDialect === "oracle") {
    extendedMap["INT"] = ["NUMBER", "INT"];
    extendedMap["INTEGER"] = ["NUMBER", "INTEGER"];
    extendedMap["DECIMAL"] = ["NUMBER", "DECIMAL"];
    extendedMap["NUMERIC"] = ["NUMBER", "NUMERIC"];
    extendedMap["VARCHAR"] = ["VARCHAR2", "VARCHAR"];
    extendedMap["CHAR"] = ["CHAR", "VARCHAR2"];
    extendedMap["TEXT"] = ["CLOB", "VARCHAR2", "TEXT"];
    extendedMap["DATETIME"] = ["TIMESTAMP", "DATE"];
    extendedMap["TIMESTAMP"] = ["TIMESTAMP", "DATE"];
    extendedMap["BLOB"] = ["BLOB", "RAW"];
    extendedMap["FLOAT"] = ["BINARY_FLOAT", "FLOAT"];
    extendedMap["DOUBLE"] = ["BINARY_DOUBLE", "DOUBLE"];
  }

  // Базовые маппинги для MySQL -> SQLite
  if (fromDialect === "mysql" && toDialect === "sqlite") {
    extendedMap["AUTO_INCREMENT"] = ["AUTOINCREMENT", "AUTO_INCREMENT"];
    extendedMap["INT"] = ["INTEGER", "INT"];
    extendedMap["INTEGER"] = ["INTEGER", "INT"];
    extendedMap["VARCHAR"] = ["TEXT", "VARCHAR"];
    extendedMap["CHAR"] = ["TEXT", "CHAR"];
    extendedMap["TEXT"] = ["TEXT", "VARCHAR"];
    extendedMap["DATETIME"] = ["TEXT", "DATETIME"];
    extendedMap["TIMESTAMP"] = ["TEXT", "TIMESTAMP"];
    extendedMap["DECIMAL"] = ["NUMERIC", "DECIMAL"];
    extendedMap["NUMERIC"] = ["NUMERIC", "DECIMAL"];
    extendedMap["BLOB"] = ["BLOB", "TEXT"];
  }

  // Базовые маппинги для MySQL -> Redshift
  if (fromDialect === "mysql" && toDialect === "redshift") {
    extendedMap["INT"] = ["INTEGER", "INT"];
    extendedMap["INTEGER"] = ["INTEGER", "INT"];
    extendedMap["DECIMAL"] = ["NUMERIC", "DECIMAL"];
    extendedMap["NUMERIC"] = ["NUMERIC", "DECIMAL"];
    extendedMap["DATETIME"] = ["TIMESTAMP", "DATE"];
    extendedMap["TIMESTAMP"] = ["TIMESTAMP", "DATE"];
    extendedMap["TEXT"] = ["VARCHAR(MAX)", "TEXT", "VARCHAR"];
    extendedMap["MEDIUMTEXT"] = ["VARCHAR(MAX)", "TEXT", "VARCHAR"];
    extendedMap["LONGTEXT"] = ["VARCHAR(MAX)", "TEXT", "VARCHAR"];
    extendedMap["BLOB"] = ["VARBYTE", "BLOB"];
    extendedMap["AUTO_INCREMENT"] = ["IDENTITY(1,1)", "AUTO_INCREMENT"];
    extendedMap["CURRENT_TIMESTAMP"] = [
      "GETDATE()",
      "SYSDATE",
      "CURRENT_TIMESTAMP",
    ];
    extendedMap["FLOAT"] = ["REAL", "FLOAT"];
    extendedMap["DOUBLE"] = ["DOUBLE PRECISION", "DOUBLE"];
    extendedMap["TINYINT"] = ["SMALLINT", "INTEGER"];
    extendedMap["SMALLINT"] = ["SMALLINT", "INTEGER"];
    extendedMap["MEDIUMINT"] = ["INTEGER", "INT"];
    extendedMap["BIGINT"] = ["BIGINT", "INTEGER"];
    extendedMap["YEAR"] = ["INTEGER", "INT"];
    extendedMap["ENUM"] = ["VARCHAR", "CHAR"];
    extendedMap["SET"] = ["VARCHAR", "TEXT"];
    extendedMap["JSON"] = ["SUPER", "VARCHAR(MAX)"];
  }
  // Базовые маппинги для MySQL -> MSSQL
  if (fromDialect === "mysql" && toDialect === "mssql") {
    extendedMap["TIMESTAMP"] = ["DATETIME2", "TIMESTAMP"];
    extendedMap["DATETIME"] = ["DATETIME2", "DATETIME"];
    extendedMap["TEXT"] = ["NVARCHAR(MAX)", "TEXT"];
    extendedMap["BLOB"] = ["VARBINARY(MAX)", "BLOB"];
    extendedMap["AUTO_INCREMENT"] = ["IDENTITY(1,1)"];
    extendedMap["CURRENT_TIMESTAMP"] = ["GETDATE()", "CURRENT_TIMESTAMP"];
    extendedMap["YEAR"] = ["INT", "SMALLINT"];
    extendedMap["ENUM"] = ["VARCHAR", "NVARCHAR"];
    extendedMap["SET"] = ["VARCHAR", "NVARCHAR"];
    extendedMap["TINYTEXT"] = ["NVARCHAR(255)", "VARCHAR(255)"];
    extendedMap["MEDIUMTEXT"] = ["NVARCHAR(MAX)", "VARCHAR(MAX)"];
    extendedMap["LONGTEXT"] = ["NVARCHAR(MAX)", "VARCHAR(MAX)"];
    extendedMap["TINYBLOB"] = ["VARBINARY(255)", "VARBINARY(255)"];
    extendedMap["MEDIUMBLOB"] = ["VARBINARY(MAX)", "VARBINARY(MAX)"];
    extendedMap["LONGBLOB"] = ["VARBINARY(MAX)", "VARBINARY(MAX)"];
  }

  return extendedMap;
};

// Новая функция для поиска изменений типов данных
const findDataTypeChanges = (
  originalLines: string[],
  convertedLines: string[],
  fromDialect: string,
  toDialect: string,
  typeConversions: Record<string, string>,
  extendedTypeMap: Record<string, string[]>,
  differences: SQLDifference[]
) => {
  // Сначала находим все типы данных с их полными именами (включая параметры)
  originalLines.forEach((originalLine, originalLineIndex) => {
    Object.keys(typeConversions).forEach((fromKeyword) => {
      const toKeyword = typeConversions[fromKeyword];

      // Пропускаем если это тип данных
      if (isDataTypeKeyword(fromKeyword)) {
        return;
      }

      // Особый случай: если toKeyword пустая строка, отмечаем как removed
      if (toKeyword === "") {
        const regex = new RegExp(`\\b${fromKeyword}\\b`, "gi");
        let match: RegExpExecArray | null;

        while ((match = regex.exec(originalLine)) !== null) {
          const position = match.index;

          if (
            isKeywordInContext(originalLine, position, fromKeyword, fromDialect)
          ) {
            // Для BigQuery проверяем, остался ли AUTO_INCREMENT в конвертированном коде
            if (
              fromDialect === "mysql" &&
              toDialect === "bigquery" &&
              fromKeyword === "AUTO_INCREMENT"
            ) {
              let foundInConverted = false;

              for (
                let i = Math.max(0, originalLineIndex - 2);
                i < Math.min(convertedLines.length, originalLineIndex + 3);
                i++
              ) {
                const bqLine = convertedLines[i];
                if (bqLine.includes("AUTO_INCREMENT")) {
                  foundInConverted = true;
                  break;
                }
              }

              if (!foundInConverted) {
                differences.push({
                  type: "removed",
                  originalWord: fromKeyword,
                  convertedWord: "",
                  description: `${fromKeyword} removed (not supported in ${toDialect})`,
                  originalLine: originalLineIndex,
                  originalPosition: position,
                  convertedLine: -1,
                  convertedPosition: -1,
                  equivalent: "",
                });
              }
            } else {
              differences.push({
                type: "removed",
                originalWord: fromKeyword,
                convertedWord: "",
                description: `${fromKeyword} removed (not supported in ${toDialect})`,
                originalLine: originalLineIndex,
                originalPosition: position,
                convertedLine: -1,
                convertedPosition: -1,
                equivalent: "",
              });
            }
          }
        }
        return;
      }

      // Пропускаем если одинаковые
      if (fromKeyword === toKeyword) {
        return;
      }

      const regex = new RegExp(`\\b${fromKeyword}\\b`, "gi");
      let match: RegExpExecArray | null;

      while ((match = regex.exec(originalLine)) !== null) {
        const position = match.index;

        if (
          isKeywordInContext(originalLine, position, fromKeyword, fromDialect)
        ) {
          const found = findMatchingKeywordInConverted(
            convertedLines,
            originalLineIndex,
            toKeyword,
            fromKeyword
          );

          if (found) {
            differences.push({
              type: "keyword",
              originalWord: fromKeyword,
              convertedWord: toKeyword,
              description: `Keyword converted from ${fromDialect} ${fromKeyword} to ${toDialect} ${toKeyword}`,
              originalLine: originalLineIndex,
              originalPosition: position,
              convertedLine: found.line,
              convertedPosition: found.position,
              equivalent: toKeyword,
            });
          }
        }
      }
    });
  });
};

// Новая функция для проверки, является ли ключевое слово типом данных
const isDataTypeKeyword = (keyword: string): boolean => {
  const dataTypeKeywords = [
    "INT",
    "INTEGER",
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "BIGINT",
    "FLOAT",
    "DOUBLE",
    "REAL",
    "DECIMAL",
    "NUMERIC",
    "VARCHAR",
    "CHAR",
    "TEXT",
    "BLOB",
    "DATE",
    "DATETIME",
    "TIMESTAMP",
    "TIME",
    "YEAR",
    "BOOLEAN",
    "JSON",
    "UUID",
    "SERIAL",
    "BIGSERIAL",
    "NUMBER",
    "CLOB",
    "RAW",
    "BINARY",
    "VARBINARY",
    "MONEY",
    "XML",
    "GEOMETRY",
    "GEOGRAPHY",
  ];
  return dataTypeKeywords.includes(keyword.toUpperCase());
};

// Новая функция для проверки контекста ключевых слов
const isKeywordInContext = (
  line: string,
  position: number,
  keyword: string,
  dialect: string
): boolean => {
  const before = line.substring(0, position);
  const after = line.substring(position + keyword.length);

  const upperKeyword = keyword.toUpperCase();

  // AUTO_INCREMENT обычно идет после типа данных
  if (upperKeyword === "AUTO_INCREMENT") {
    return /\b(INT|INTEGER|BIGINT|SMALLINT|TINYINT|MEDIUMINT|INT64)\s+$/i.test(
      before
    );
  }

  // FOREIGN KEY обычно в конце определения столбца или таблицы
  if (upperKeyword === "FOREIGN KEY") {
    return true; // FOREIGN KEY легко распознать по синтаксису
  }

  // ENGINE, CHARSET, COLLATE обычно в конце определения таблицы
  if (["ENGINE", "CHARSET", "COLLATE"].includes(upperKeyword)) {
    return true;
  }

  // UNSIGNED, ZEROFILL обычно после типа данных
  if (["UNSIGNED", "ZEROFILL"].includes(upperKeyword)) {
    return /\b(INT|INTEGER|BIGINT|SMALLINT|TINYINT|MEDIUMINT|FLOAT|DOUBLE|DECIMAL|NUMERIC)\s+$/i.test(
      before
    );
  }

  // Проверяем, что это отдельное слово
  const isStandalone =
    (position === 0 || !/\w/.test(line.charAt(position - 1))) &&
    (position + keyword.length === line.length ||
      !/\w/.test(line.charAt(position + keyword.length)));

  return isStandalone;
};

// Новая функция для поиска ключевых слов в конвертированном коде
const findMatchingKeywordInConverted = (
  convertedLines: string[],
  originalLineIndex: number,
  targetKeyword: string,
  originalKeyword: string
): { line: number; position: number } | null => {
  const searchStart = Math.max(0, originalLineIndex - 2);
  const searchEnd = Math.min(convertedLines.length, originalLineIndex + 3);

  for (let i = searchStart; i < searchEnd; i++) {
    const line = convertedLines[i];
    const regex = new RegExp(`\\b${targetKeyword}\\b`, "gi");
    const match = regex.exec(line);

    if (match) {
      return {
        line: i,
        position: match.index,
      };
    }
  }

  return null;
};

// Проверяем, что слово является типом данных в правильном контексте
const isDataTypeInContext = (
  line: string,
  position: number,
  type: string
): boolean => {
  const before = line.substring(0, position);
  const after = line.substring(position + type.length);

  const upperBefore = before.toUpperCase();
  const upperAfter = after.toUpperCase();
  const upperLine = line.toUpperCase();

  // Тип данных может быть в разных контекстах:

  // 1. После имени столбца в определении таблицы
  // Пример: "column_name INTEGER"
  const columnDefinitionPattern = /(\s+|^)(\w+)\s+$/i;
  const isColumnDefinition = columnDefinitionPattern.test(before);

  // 2. В определении параметра функции/процедуры
  // Пример: "param_name INTEGER"
  const paramPattern = /\(\s*\w+\s+$/i;
  const isParamDefinition = paramPattern.test(before);

  // 3. В определении типа возврата
  // Пример: "RETURNS INTEGER"
  const returnsPattern = /\bRETURNS\s+$/i;
  const isReturnType = returnsPattern.test(before);

  // 4. После AS в CAST
  // Пример: "CAST(... AS INTEGER)"
  const castPattern = /CAST\s*\(.*AS\s+$/i;
  const isCastType = castPattern.test(before);

  // 5. В условиях FOREIGN KEY
  // Пример: "FOREIGN KEY (column) REFERENCES table(column)"
  // В этом случае INTEGER может быть частью определения таблицы в REFERENCES
  // Но в нашем случае последний INTEGER - это просто тип столбца в другой таблице

  // 6. Проверяем, что это не часть другого слова
  const isStandaloneWord =
    (position === 0 || !/\w/.test(line.charAt(position - 1))) &&
    (position + type.length === line.length ||
      !/\w/.test(line.charAt(position + type.length)));

  // Проверяем, что после типа идут допустимые символы
  const validAfterChars =
    /^(\s*|[,\])\s]|\s+(NOT\b|DEFAULT\b|PRIMARY\b|FOREIGN\b|KEY\b|UNIQUE\b|CHECK\b|REFERENCES\b|,\s*|\)\s*|$))/i;
  const hasValidAfter = validAfterChars.test(after);

  // Также тип данных может быть в контексте REFERENCES (определение удаленной таблицы)
  // Пример: "REFERENCES other_table(column)"
  // В этом случае тип не упоминается явно, только имя столбца

  // Проверяем различные контексты
  if (!isStandaloneWord) {
    return false;
  }

  // Если это явно тип данных в определении столбца
  if (isColumnDefinition && hasValidAfter) {
    return true;
  }

  // Если это параметр или возвращаемый тип
  if ((isParamDefinition || isReturnType || isCastType) && hasValidAfter) {
    return true;
  }

  // Специальная проверка для INTEGER в контексте CREATE TABLE
  // Ищем паттерн "column_name INTEGER" где-то в строке
  const integerPattern = /\b(\w+)\s+INTEGER\b/gi;
  const integerMatch = integerPattern.exec(upperLine);
  if (integerMatch && integerMatch.index === position) {
    // Проверяем, что перед INTEGER идет имя столбца
    const columnNameMatch = before.match(/(\w+)\s+$/);
    if (columnNameMatch) {
      return true;
    }
  }

  return false;
};

// Новая функция для поиска изменений функций
// diff.ts - исправляем findFunctionChanges для PostgreSQL
const findFunctionChanges = (
  originalLines: string[],
  convertedLines: string[],
  fromDialect: string,
  toDialect: string,
  differences: SQLDifference[]
) => {
  // MySQL -> PostgreSQL: CURRENT_TIMESTAMP -> CURRENT_TIMESTAMP (остается тем же)
  if (fromDialect === "mysql" && toDialect === "postgres") {
    originalLines.forEach((line, lineIndex) => {
      // 1. Ищем TIMESTAMP как тип данных (не в контексте DEFAULT CURRENT_TIMESTAMP)
      const timestampRegex = /\bTIMESTAMP\b/gi;
      let match: RegExpExecArray | null;

      while ((match = timestampRegex.exec(line)) !== null) {
        const position = match.index;

        // Проверяем, что это тип данных, а не часть другого слова
        if (isDataTypeInContext(line, position, "TIMESTAMP")) {
          // Ищем TIMESTAMPTZ в PostgreSQL
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const pgLine = convertedLines[i];
            const pgTimestampRegex = /\bTIMESTAMPTZ\b/gi;
            const pgMatch = pgTimestampRegex.exec(pgLine);

            if (pgMatch) {
              differences.push({
                type: "datatype",
                originalWord: "TIMESTAMP",
                convertedWord: "TIMESTAMPTZ",
                description: "Timestamp with time zone (MySQL → PostgreSQL)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: pgMatch.index,
                equivalent: "TIMESTAMPTZ",
              });
              break;
            }
          }
        }
      }

      // 2. Ищем DATETIME -> TIMESTAMP/TIMESTAMPTZ
      const datetimeRegex = /\bDATETIME\b/gi;
      while ((match = datetimeRegex.exec(line)) !== null) {
        const position = match.index;

        if (isDataTypeInContext(line, position, "DATETIME")) {
          // Ищем TIMESTAMP или TIMESTAMPTZ в PostgreSQL
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const pgLine = convertedLines[i];

            // Сначала проверяем TIMESTAMPTZ
            const pgTimestampRegex = /\bTIMESTAMPTZ\b/gi;
            const pgTimestampMatch = pgTimestampRegex.exec(pgLine);

            if (pgTimestampMatch) {
              differences.push({
                type: "datatype",
                originalWord: "DATETIME",
                convertedWord: "TIMESTAMPTZ",
                description:
                  "Datetime converted to timestamp with time zone (MySQL → PostgreSQL)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: pgTimestampMatch.index,
                equivalent: "TIMESTAMPTZ",
              });
              break;
            }

            // Затем проверяем TIMESTAMP
            const pgSimpleTimestampRegex = /\bTIMESTAMP\b/gi;
            const pgSimpleMatch = pgSimpleTimestampRegex.exec(pgLine);

            if (pgSimpleMatch) {
              differences.push({
                type: "datatype",
                originalWord: "DATETIME",
                convertedWord: "TIMESTAMP",
                description:
                  "Datetime converted to timestamp (MySQL → PostgreSQL)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: pgSimpleMatch.index,
                equivalent: "TIMESTAMP",
              });
              break;
            }
          }
        }
      }

      // 3. Ищем DEFAULT CURRENT_TIMESTAMP как функцию (без изменения)
      // Но НЕ создаем различие для самой функции, только если это часть изменения типа
      const defaultTimestampRegex = /\bDEFAULT\s+CURRENT_TIMESTAMP\b/gi;
      let timestampMatch: RegExpExecArray | null;
      
      // Просто ищем, но не создаем различий
      // Если нужно показать, что DEFAULT CURRENT_TIMESTAMP остался тем же, можно добавить:
      while ((timestampMatch = defaultTimestampRegex.exec(line)) !== null) {
        // Ищем ту же конструкцию в PostgreSQL
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const pgLine = convertedLines[i];
          const pgDefaultRegex = /\bDEFAULT\s+CURRENT_TIMESTAMP\b/gi;
          const pgDefaultMatch = pgDefaultRegex.exec(pgLine);

          if (pgDefaultMatch) {
            // CURRENT_TIMESTAMP остается тем же в PostgreSQL
            // Не создаем различие, так как это не изменение
            break;
          }
        }
      }
    });
  }

  // MySQL -> Snowflake: CURRENT_TIMESTAMP -> CURRENT_TIMESTAMP()
  if (fromDialect === "mysql" && toDialect === "snowflake") {
    originalLines.forEach((line, lineIndex) => {
      // Ищем DEFAULT CURRENT_TIMESTAMP
      const defaultTimestampRegex = /\bDEFAULT\s+CURRENT_TIMESTAMP\b/gi;
      let match: RegExpExecArray | null;

      while ((match = defaultTimestampRegex.exec(line)) !== null) {
        // Ищем в Snowflake CURRENT_TIMESTAMP()
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const sfLine = convertedLines[i];
          const sfTimestampRegex = /\bCURRENT_TIMESTAMP\s*\(\)/gi;
          const sfMatch = sfTimestampRegex.exec(sfLine);

          if (sfMatch) {
            differences.push({
              type: "function",
              originalWord: "CURRENT_TIMESTAMP",
              convertedWord: "CURRENT_TIMESTAMP()",
              description:
                "Timestamp function (requires parentheses in Snowflake)",
              originalLine: lineIndex,
              originalPosition: match.index + 8, // После "DEFAULT "
              convertedLine: i,
              convertedPosition: sfMatch.index,
              equivalent: "CURRENT_TIMESTAMP()",
            });
            break;
          }
        }
      }
    });
  }

  // MySQL -> BigQuery: специфичные проверки
  if (fromDialect === "mysql" && toDialect === "bigquery") {
    originalLines.forEach((line, lineIndex) => {
      // Проверяем другие неподдерживаемые функции
      const unsupportedFunctions = [
        {
          regex: /\bYEAR\b/gi,
          name: "YEAR",
          description: "YEAR type not supported",
        },
        {
          regex: /\bENUM\b/gi,
          name: "ENUM",
          description: "ENUM type not supported",
        },
        {
          regex: /\bSET\b/gi,
          name: "SET",
          description: "SET type not supported",
        },
        {
          regex: /\bTINYTEXT\b/gi,
          name: "TINYTEXT",
          description: "TINYTEXT type not supported",
        },
        {
          regex: /\bMEDIUMTEXT\b/gi,
          name: "MEDIUMTEXT",
          description: "MEDIUMTEXT type not supported",
        },
        {
          regex: /\bLONGTEXT\b/gi,
          name: "LONGTEXT",
          description: "LONGTEXT type not supported",
        },
      ];

      unsupportedFunctions.forEach(({ regex, name, description }) => {
        let match: RegExpExecArray | null;
        while ((match = regex.exec(line)) !== null) {
          // Проверяем контекст
          if (isDataTypeInContext(line, match.index, name)) {
            differences.push({
              type: "removed",
              originalWord: name,
              convertedWord: "",
              description: `❌ ${description} in BigQuery`,
              originalLine: lineIndex,
              originalPosition: match.index,
              convertedLine: -1,
              convertedPosition: -1,
              equivalent: "",
            });
          }
        }
      });
    });
  }
  
  // MySQL -> MSSQL: CURRENT_TIMESTAMP -> GETDATE()
  if (fromDialect === "mysql" && toDialect === "mssql") {
    originalLines.forEach((line, lineIndex) => {
      // Ищем DEFAULT CURRENT_TIMESTAMP
      const defaultTimestampRegex = /\bDEFAULT\s+CURRENT_TIMESTAMP\b/gi;
      let match: RegExpExecArray | null;

      while ((match = defaultTimestampRegex.exec(line)) !== null) {
        // Ищем DEFAULT GETDATE() в MSSQL
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const mssqlLine = convertedLines[i];
          const getdateRegex = /\bDEFAULT\s+GETDATE\s*\(\)/gi;
          const getdateMatch = getdateRegex.exec(mssqlLine);

          if (getdateMatch) {
            differences.push({
              type: "function",
              originalWord: "DEFAULT CURRENT_TIMESTAMP",
              convertedWord: "DEFAULT GETDATE()",
              description: "Timestamp function (MySQL → SQL Server)",
              originalLine: lineIndex,
              originalPosition: match.index,
              convertedLine: i,
              convertedPosition: getdateMatch.index,
              equivalent: "DEFAULT GETDATE()",
            });
            break;
          }
        }
      }

      // Также ищем просто CURRENT_TIMESTAMP в других контекстах
      const timestampRegex = /\bCURRENT_TIMESTAMP\b/gi;
      while ((match = timestampRegex.exec(line)) !== null) {
        const position = match.index;

        // Проверяем, что это не часть DEFAULT CURRENT_TIMESTAMP (уже обработано)
        const before = line.substring(0, position);
        if (!before.endsWith("DEFAULT ")) {
          // Ищем GETDATE() в MSSQL
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const mssqlLine = convertedLines[i];
            const getdateRegex = /\bGETDATE\s*\(\)/gi;
            const getdateMatch = getdateRegex.exec(mssqlLine);

            if (getdateMatch) {
              differences.push({
                type: "function",
                originalWord: "CURRENT_TIMESTAMP",
                convertedWord: "GETDATE()",
                description: "Current timestamp function (MySQL → SQL Server)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: getdateMatch.index,
                equivalent: "GETDATE()",
              });
              break;
            }
          }
        }
      }
    });
  }
};

// Специальные случаи, которые не покрываются простой картой конвертаций
const findSpecialCases = (
  originalLines: string[],
  convertedLines: string[],
  fromDialect: string,
  toDialect: string,
  differences: SQLDifference[]
) => {
  // MySQL -> PostgreSQL: AUTO_INCREMENT -> GENERATED BY DEFAULT AS IDENTITY
  if (fromDialect === "mysql" && toDialect === "postgres") {
    originalLines.forEach((line, lineIndex) => {
      const autoIncRegex = /\bAUTO_INCREMENT\b/gi;
      let match: RegExpExecArray | null;

      while ((match = autoIncRegex.exec(line)) !== null) {
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const pgLine = convertedLines[i];
          const identityRegex = /\bIDENTITY\b/gi;
          const identityMatch = identityRegex.exec(pgLine);

          if (identityMatch) {
            differences.push({
              type: "keyword",
              originalWord: "AUTO_INCREMENT",
              convertedWord: "GENERATED BY DEFAULT AS IDENTITY",
              description: "Auto-increment converted to identity column",
              originalLine: lineIndex,
              originalPosition: match.index,
              convertedLine: i,
              convertedPosition: identityMatch.index,
              equivalent: "GENERATED BY DEFAULT AS IDENTITY",
            });
            break;
          }
        }
      }
    });
  }

  // MySQL -> BigQuery: обработка неподдерживаемых конструкций
  if (fromDialect === "mysql" && toDialect === "bigquery") {
    originalLines.forEach((line, lineIndex) => {
      // Ищем FOREIGN KEY
      const foreignKeyRegex =
        /\bFOREIGN\s+KEY\s*\([^)]+\)\s+REFERENCES\s+\w+\s*\([^)]+\)/gi;
      let match: RegExpExecArray | null;

      while ((match = foreignKeyRegex.exec(line)) !== null) {
        const fullMatch = match[0];
        const position = match.index;

        differences.push({
          type: "removed",
          originalWord: fullMatch,
          convertedWord: "",
          description: "❌ FOREIGN KEY removed (not supported in BigQuery)",
          originalLine: lineIndex,
          originalPosition: position,
          convertedLine: -1,
          convertedPosition: -1,
          equivalent: "",
        });
      }

      // Ищем AUTO_INCREMENT - УПРОЩАЕМ ЛОГИКУ
      const autoIncRegex = /\bAUTO_INCREMENT\b/gi;
      while ((match = autoIncRegex.exec(line)) !== null) {
        const position = match.index;

        differences.push({
          type: "removed",
          originalWord: "AUTO_INCREMENT",
          convertedWord: "",
          description: "❌ AUTO_INCREMENT removed (not supported in BigQuery)",
          originalLine: lineIndex,
          originalPosition: position,
          convertedLine: -1,
          convertedPosition: -1,
          equivalent: "",
        });
      }

      // Ищем другие неподдерживаемые ключевые слова
      const unsupportedKeywords = [
        { regex: /\bENGINE\b/gi, name: "ENGINE", desc: "ENGINE clause" },
        { regex: /\bCHARSET\b/gi, name: "CHARSET", desc: "CHARSET clause" },
        { regex: /\bCOLLATE\b/gi, name: "COLLATE", desc: "COLLATE clause" },
        {
          regex: /\bUNSIGNED\b/gi,
          name: "UNSIGNED",
          desc: "UNSIGNED modifier",
        },
        {
          regex: /\bZEROFILL\b/gi,
          name: "ZEROFILL",
          desc: "ZEROFILL modifier",
        },
      ];

      unsupportedKeywords.forEach(({ regex, name, desc }) => {
        while ((match = regex.exec(line)) !== null) {
          differences.push({
            type: "removed",
            originalWord: name,
            convertedWord: "",
            description: `❌ ${desc} removed (not supported in BigQuery)`,
            originalLine: lineIndex,
            originalPosition: match.index,
            convertedLine: -1,
            convertedPosition: -1,
            equivalent: "",
          });
        }
      });
    });
  }

  // MySQL -> Snowflake: специальные случаи
  if (fromDialect === "mysql" && toDialect === "snowflake") {
    originalLines.forEach((line, lineIndex) => {
      // Ищем AUTO_INCREMENT -> AUTOINCREMENT
      const autoIncRegex = /\bAUTO_INCREMENT\b/gi;
      let match: RegExpExecArray | null;

      while ((match = autoIncRegex.exec(line)) !== null) {
        const position = match.index;

        // Ищем AUTOINCREMENT в Snowflake
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const sfLine = convertedLines[i];
          const autoincrementRegex = /\bAUTOINCREMENT\b/gi;
          const autoincrementMatch = autoincrementRegex.exec(sfLine);

          if (autoincrementMatch) {
            differences.push({
              type: "keyword",
              originalWord: "AUTO_INCREMENT",
              convertedWord: "AUTOINCREMENT",
              description: "Auto-increment (MySQL → Snowflake)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: autoincrementMatch.index,
              equivalent: "AUTOINCREMENT",
            });
            break;
          }
        }
      }

      // Ищем INT -> INTEGER/NUMBER
      const intRegex = /\bINT\b/gi;
      while ((match = intRegex.exec(line)) !== null) {
        const position = match.index;

        // Проверяем контекст (это действительно тип данных)
        if (isDataTypeInContext(line, position, "INT")) {
          // Ищем INTEGER или NUMBER в Snowflake
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const sfLine = convertedLines[i];

            // Проверяем INTEGER
            const integerRegex = /\bINTEGER\b/gi;
            const integerMatch = integerRegex.exec(sfLine);

            if (integerMatch) {
              differences.push({
                type: "datatype",
                originalWord: "INT",
                convertedWord: "INTEGER",
                description: "Integer type (MySQL → Snowflake)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: integerMatch.index,
                equivalent: "INTEGER",
              });
              break;
            }

            // Также проверяем NUMBER
            const numberRegex = /\bNUMBER\b/gi;
            const numberMatch = numberRegex.exec(sfLine);

            if (numberMatch) {
              differences.push({
                type: "datatype",
                originalWord: "INT",
                convertedWord: "NUMBER",
                description:
                  "Integer type converted to NUMBER (MySQL → Snowflake)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: numberMatch.index,
                equivalent: "NUMBER",
              });
              break;
            }
          }
        }
      }

      // Ищем DECIMAL -> NUMBER
      const decimalRegex = /\bDECIMAL\b/gi;
      while ((match = decimalRegex.exec(line)) !== null) {
        const position = match.index;

        if (isDataTypeInContext(line, position, "DECIMAL")) {
          // Ищем NUMBER в Snowflake
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const sfLine = convertedLines[i];
            const numberRegex = /\bNUMBER\b/gi;
            const numberMatch = numberRegex.exec(sfLine);

            if (numberMatch) {
              differences.push({
                type: "datatype",
                originalWord: "DECIMAL",
                convertedWord: "NUMBER",
                description:
                  "Decimal type converted to NUMBER (MySQL → Snowflake)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: numberMatch.index,
                equivalent: "NUMBER",
              });
              break;
            }
          }
        }
      }

      // Ищем NUMERIC -> NUMBER
      const numericRegex = /\bNUMERIC\b/gi;
      while ((match = numericRegex.exec(line)) !== null) {
        const position = match.index;

        if (isDataTypeInContext(line, position, "NUMERIC")) {
          // Ищем NUMBER в Snowflake
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const sfLine = convertedLines[i];
            const numberRegex = /\bNUMBER\b/gi;
            const numberMatch = numberRegex.exec(sfLine);

            if (numberMatch) {
              differences.push({
                type: "datatype",
                originalWord: "NUMERIC",
                convertedWord: "NUMBER",
                description:
                  "Numeric type converted to NUMBER (MySQL → Snowflake)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: numberMatch.index,
                equivalent: "NUMBER",
              });
              break;
            }
          }
        }
      }
    });
  }

  // MySQL -> Oracle: обработка неподдерживаемых конструкций
  if (fromDialect === "mysql" && toDialect === "oracle") {
    originalLines.forEach((line, lineIndex) => {
      // Ищем AUTO_INCREMENT - отмечаем как removed
      const autoIncRegex = /\bAUTO_INCREMENT\b/gi;
      let match: RegExpExecArray | null;

      while ((match = autoIncRegex.exec(line)) !== null) {
        const position = match.index;

        differences.push({
          type: "removed",
          originalWord: "AUTO_INCREMENT",
          convertedWord: "",
          description: "❌ AUTO_INCREMENT removed (not supported in Oracle)",
          originalLine: lineIndex,
          originalPosition: position,
          convertedLine: -1,
          convertedPosition: -1,
          equivalent: "",
        });
      }

      // Ищем ENGINE, CHARSET, COLLATE - не поддерживаются в Oracle
      const unsupportedKeywords = [
        { regex: /\bENGINE\b/gi, name: "ENGINE", desc: "ENGINE clause" },
        { regex: /\bCHARSET\b/gi, name: "CHARSET", desc: "CHARSET clause" },
        { regex: /\bCOLLATE\b/gi, name: "COLLATE", desc: "COLLATE clause" },
        {
          regex: /\bUNSIGNED\b/gi,
          name: "UNSIGNED",
          desc: "UNSIGNED modifier",
        },
        {
          regex: /\bZEROFILL\b/gi,
          name: "ZEROFILL",
          desc: "ZEROFILL modifier",
        },
      ];

      unsupportedKeywords.forEach(({ regex, name, desc }) => {
        while ((match = regex.exec(line)) !== null) {
          differences.push({
            type: "removed",
            originalWord: name,
            convertedWord: "",
            description: `❌ ${desc} removed (not supported in Oracle)`,
            originalLine: lineIndex,
            originalPosition: match.index,
            convertedLine: -1,
            convertedPosition: -1,
            equivalent: "",
          });
        }
      });
    });
  }

  // MySQL -> SQLite: специальные случаи
  if (fromDialect === "mysql" && toDialect === "sqlite") {
    originalLines.forEach((line, lineIndex) => {
      // Ищем AUTO_INCREMENT -> AUTOINCREMENT
      const autoIncRegex = /\bAUTO_INCREMENT\b/gi;
      let match: RegExpExecArray | null;

      while ((match = autoIncRegex.exec(line)) !== null) {
        const position = match.index;

        // Ищем AUTOINCREMENT в SQLite
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const sqliteLine = convertedLines[i];
          const autoincrementRegex = /\bAUTOINCREMENT\b/gi;
          const autoincrementMatch = autoincrementRegex.exec(sqliteLine);

          if (autoincrementMatch) {
            differences.push({
              type: "keyword",
              originalWord: "AUTO_INCREMENT",
              convertedWord: "AUTOINCREMENT",
              description: "Auto-increment (MySQL → SQLite)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: autoincrementMatch.index,
              equivalent: "AUTOINCREMENT",
            });
            break;
          }
        }
      }

      // Ищем INT -> INTEGER
      const intRegex = /\bINT\b/gi;
      while ((match = intRegex.exec(line)) !== null) {
        const position = match.index;

        // Проверяем контекст (это действительно тип данных)
        if (isDataTypeInContext(line, position, "INT")) {
          // Ищем INTEGER в SQLite
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const sqliteLine = convertedLines[i];
            const integerRegex = /\bINTEGER\b/gi;
            const integerMatch = integerRegex.exec(sqliteLine);

            if (integerMatch) {
              differences.push({
                type: "datatype",
                originalWord: "INT",
                convertedWord: "INTEGER",
                description: "Integer type (MySQL → SQLite)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: integerMatch.index,
                equivalent: "INTEGER",
              });
              break;
            }
          }
        }
      }

      // Ищем VARCHAR -> TEXT
      const varcharRegex = /\bVARCHAR\b/gi;
      while ((match = varcharRegex.exec(line)) !== null) {
        const position = match.index;

        // Проверяем контекст (это действительно тип данных)
        if (isDataTypeInContext(line, position, "VARCHAR")) {
          // Ищем TEXT в SQLite
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const sqliteLine = convertedLines[i];
            const textRegex = /\bTEXT\b/gi;
            const textMatch = textRegex.exec(sqliteLine);

            if (textMatch) {
              differences.push({
                type: "datatype",
                originalWord: "VARCHAR",
                convertedWord: "TEXT",
                description: "String type converted to TEXT (MySQL → SQLite)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: textMatch.index,
                equivalent: "TEXT",
              });
              break;
            }
          }
        }
      }

      // Ищем DATETIME/TIMESTAMP -> TEXT
      const datetimeRegex = /\b(DATETIME|TIMESTAMP)\b/gi;
      while ((match = datetimeRegex.exec(line)) !== null) {
        const position = match.index;
        const matchedText = match[0];

        // Проверяем контекст (это действительно тип данных)
        if (isDataTypeInContext(line, position, matchedText)) {
          // Ищем TEXT в SQLite
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const sqliteLine = convertedLines[i];
            const textRegex = /\bTEXT\b/gi;
            const textMatch = textRegex.exec(sqliteLine);

            if (textMatch) {
              differences.push({
                type: "datatype",
                originalWord: matchedText,
                convertedWord: "TEXT",
                description: `${matchedText} converted to TEXT (MySQL → SQLite)`,
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: textMatch.index,
                equivalent: "TEXT",
              });
              break;
            }
          }
        }
      }

      // Ищем UNSIGNED/ZEROFILL - не поддерживаются в SQLite
      const unsupportedKeywords = [
        {
          regex: /\bUNSIGNED\b/gi,
          name: "UNSIGNED",
          desc: "UNSIGNED modifier",
        },
        {
          regex: /\bZEROFILL\b/gi,
          name: "ZEROFILL",
          desc: "ZEROFILL modifier",
        },
        { regex: /\bENGINE\b/gi, name: "ENGINE", desc: "ENGINE clause" },
        { regex: /\bCHARSET\b/gi, name: "CHARSET", desc: "CHARSET clause" },
        { regex: /\bCOLLATE\b/gi, name: "COLLATE", desc: "COLLATE clause" },
      ];

      unsupportedKeywords.forEach(({ regex, name, desc }) => {
        while ((match = regex.exec(line)) !== null) {
          differences.push({
            type: "removed",
            originalWord: name,
            convertedWord: "",
            description: `❌ ${desc} removed (not supported in SQLite)`,
            originalLine: lineIndex,
            originalPosition: match.index,
            convertedLine: -1,
            convertedPosition: -1,
            equivalent: "",
          });
        }
      });
    });
  }
  // MySQL -> REDSHIFT: специальные случаи
  if (fromDialect === "mysql" && toDialect === "redshift") {
    originalLines.forEach((line, lineIndex) => {
      // Ищем AUTO_INCREMENT -> IDENTITY(1,1)
      const autoIncRegex = /\bAUTO_INCREMENT\b/gi;
      let match: RegExpExecArray | null;

      while ((match = autoIncRegex.exec(line)) !== null) {
        const position = match.index;

        // Ищем IDENTITY(1,1) в Redshift
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const rsLine = convertedLines[i];
          const identityRegex = /\bIDENTITY\s*\(\s*1\s*,\s*1\s*\)/gi;
          const identityMatch = identityRegex.exec(rsLine);

          if (identityMatch) {
            differences.push({
              type: "keyword",
              originalWord: "AUTO_INCREMENT",
              convertedWord: "IDENTITY(1,1)",
              description: "Auto-increment converted to Redshift IDENTITY",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: identityMatch.index,
              equivalent: "IDENTITY(1,1)",
            });
            break;
          }
        }
      }

      // Ищем CURRENT_TIMESTAMP -> GETDATE() или SYSDATE
      const currentTimestampRegex = /\bCURRENT_TIMESTAMP\b/gi;
      while ((match = currentTimestampRegex.exec(line)) !== null) {
        const position = match.index;

        // Ищем GETDATE() или SYSDATE в Redshift
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const rsLine = convertedLines[i];

          // Проверяем GETDATE()
          const getdateRegex = /\bGETDATE\s*\(\s*\)/gi;
          const getdateMatch = getdateRegex.exec(rsLine);

          if (getdateMatch) {
            differences.push({
              type: "function",
              originalWord: "CURRENT_TIMESTAMP",
              convertedWord: "GETDATE()",
              description: "Timestamp function (MySQL → Redshift)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: getdateMatch.index,
              equivalent: "GETDATE()",
            });
            break;
          }

          // Также проверяем SYSDATE
          const sysdateRegex = /\bSYSDATE\b/gi;
          const sysdateMatch = sysdateRegex.exec(rsLine);

          if (sysdateMatch) {
            differences.push({
              type: "function",
              originalWord: "CURRENT_TIMESTAMP",
              convertedWord: "SYSDATE",
              description: "Timestamp function (MySQL → Redshift)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: sysdateMatch.index,
              equivalent: "SYSDATE",
            });
            break;
          }
        }
      }

      // Ищем INT -> INTEGER (если не сконвертировалось автоматически)
      const intRegex = /\bINT\b/gi;
      while ((match = intRegex.exec(line)) !== null) {
        const position = match.index;

        if (isDataTypeInContext(line, position, "INT")) {
          // Ищем INTEGER в Redshift
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const rsLine = convertedLines[i];
            const integerRegex = /\bINTEGER\b/gi;
            const integerMatch = integerRegex.exec(rsLine);

            if (integerMatch) {
              differences.push({
                type: "datatype",
                originalWord: "INT",
                convertedWord: "INTEGER",
                description: "Integer type (MySQL → Redshift)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: integerMatch.index,
                equivalent: "INTEGER",
              });
              break;
            }
          }
        }
      }

      // Ищем ENGINE, CHARSET, COLLATE - не поддерживаются в Redshift
      const unsupportedKeywords = [
        { regex: /\bENGINE\b/gi, name: "ENGINE", desc: "ENGINE clause" },
        { regex: /\bCHARSET\b/gi, name: "CHARSET", desc: "CHARSET clause" },
        { regex: /\bCOLLATE\b/gi, name: "COLLATE", desc: "COLLATE clause" },
        {
          regex: /\bUNSIGNED\b/gi,
          name: "UNSIGNED",
          desc: "UNSIGNED modifier",
        },
        {
          regex: /\bZEROFILL\b/gi,
          name: "ZEROFILL",
          desc: "ZEROFILL modifier",
        },
        { regex: /\bYEAR\b/gi, name: "YEAR", desc: "YEAR type" },
        { regex: /\bENUM\b/gi, name: "ENUM", desc: "ENUM type" },
        { regex: /\bSET\b/gi, name: "SET", desc: "SET type" },
      ];

      unsupportedKeywords.forEach(({ regex, name, desc }) => {
        while ((match = regex.exec(line)) !== null) {
          const position = match.index;

          // Для типов данных проверяем контекст
          if (["YEAR", "ENUM", "SET"].includes(name)) {
            if (isDataTypeInContext(line, position, name)) {
              differences.push({
                type: "removed",
                originalWord: name,
                convertedWord: "",
                description: `❌ ${desc} removed (not supported in Redshift)`,
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: -1,
                convertedPosition: -1,
                equivalent: "",
              });
            }
          } else {
            // Для других ключевых слов принимаем в любом контексте
            differences.push({
              type: "removed",
              originalWord: name,
              convertedWord: "",
              description: `❌ ${desc} removed (not supported in Redshift)`,
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: -1,
              convertedPosition: -1,
              equivalent: "",
            });
          }
        }
      });
    });
  }
  // MySQL -> MSSQL: обработка конвертаций
  if (fromDialect === "mysql" && toDialect === "mssql") {
    originalLines.forEach((line, lineIndex) => {
      // Ищем AUTO_INCREMENT -> IDENTITY(1,1)
      const autoIncRegex = /\bAUTO_INCREMENT\b/gi;
      let match: RegExpExecArray | null;

      while ((match = autoIncRegex.exec(line)) !== null) {
        const position = match.index;

        // Ищем IDENTITY(1,1) в MSSQL
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const mssqlLine = convertedLines[i];
          const identityRegex = /\bIDENTITY\s*\(\s*1\s*,\s*1\s*\)/gi;
          const identityMatch = identityRegex.exec(mssqlLine);

          if (identityMatch) {
            differences.push({
              type: "keyword",
              originalWord: "AUTO_INCREMENT",
              convertedWord: "IDENTITY(1,1)",
              description: "Auto-increment converted to SQL Server identity",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: identityMatch.index,
              equivalent: "IDENTITY(1,1)",
            });
            break;
          }
        }
      }

      // Ищем DEFAULT CURRENT_TIMESTAMP -> DEFAULT GETDATE()
      const currentTimestampRegex = /\bDEFAULT\s+CURRENT_TIMESTAMP\b/gi;
      while ((match = currentTimestampRegex.exec(line)) !== null) {
        const position = match.index;

        // Ищем DEFAULT GETDATE() в MSSQL
        for (
          let i = Math.max(0, lineIndex - 2);
          i < Math.min(convertedLines.length, lineIndex + 3);
          i++
        ) {
          const mssqlLine = convertedLines[i];
          const getdateRegex = /\bDEFAULT\s+GETDATE\s*\(\)/gi;
          const getdateMatch = getdateRegex.exec(mssqlLine);

          if (getdateMatch) {
            differences.push({
              type: "function",
              originalWord: "DEFAULT CURRENT_TIMESTAMP",
              convertedWord: "DEFAULT GETDATE()",
              description: "Timestamp function (MySQL → SQL Server)",
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: i,
              convertedPosition: getdateMatch.index,
              equivalent: "DEFAULT GETDATE()",
            });
            break;
          }
        }
      }

      // Ищем TIMESTAMP -> DATETIME2
      const timestampRegex = /\bTIMESTAMP\b/gi;
      while ((match = timestampRegex.exec(line)) !== null) {
        const position = match.index;

        // Проверяем контекст (это тип данных, не часть другого слова)
        if (isDataTypeInContext(line, position, "TIMESTAMP")) {
          // Ищем DATETIME2 в MSSQL
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const mssqlLine = convertedLines[i];
            const datetime2Regex = /\bDATETIME2\b/gi;
            const datetime2Match = datetime2Regex.exec(mssqlLine);

            if (datetime2Match) {
              differences.push({
                type: "datatype",
                originalWord: "TIMESTAMP",
                convertedWord: "DATETIME2",
                description: "Timestamp type (MySQL → SQL Server)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: datetime2Match.index,
                equivalent: "DATETIME2",
              });
              break;
            }
          }
        }
      }

      // Ищем DATETIME -> DATETIME2
      const datetimeRegex = /\bDATETIME\b/gi;
      while ((match = datetimeRegex.exec(line)) !== null) {
        const position = match.index;

        // Проверяем контекст (это тип данных)
        if (isDataTypeInContext(line, position, "DATETIME")) {
          // Ищем DATETIME2 в MSSQL
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const mssqlLine = convertedLines[i];
            const datetime2Regex = /\bDATETIME2\b/gi;
            const datetime2Match = datetime2Regex.exec(mssqlLine);

            if (datetime2Match) {
              differences.push({
                type: "datatype",
                originalWord: "DATETIME",
                convertedWord: "DATETIME2",
                description: "Datetime type (MySQL → SQL Server)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: datetime2Match.index,
                equivalent: "DATETIME2",
              });
              break;
            }
          }
        }
      }

      // Ищем TEXT -> NVARCHAR(MAX)
      const textRegex = /\bTEXT\b/gi;
      while ((match = textRegex.exec(line)) !== null) {
        const position = match.index;

        if (isDataTypeInContext(line, position, "TEXT")) {
          // Ищем NVARCHAR(MAX) в MSSQL
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const mssqlLine = convertedLines[i];
            const nvarcharRegex = /\bNVARCHAR\s*\(\s*MAX\s*\)/gi;
            const nvarcharMatch = nvarcharRegex.exec(mssqlLine);

            if (nvarcharMatch) {
              differences.push({
                type: "datatype",
                originalWord: "TEXT",
                convertedWord: "NVARCHAR(MAX)",
                description: "Text type (MySQL → SQL Server)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: nvarcharMatch.index,
                equivalent: "NVARCHAR(MAX)",
              });
              break;
            }
          }
        }
      }

      // Ищем BLOB -> VARBINARY(MAX)
      const blobRegex = /\bBLOB\b/gi;
      while ((match = blobRegex.exec(line)) !== null) {
        const position = match.index;

        if (isDataTypeInContext(line, position, "BLOB")) {
          // Ищем VARBINARY(MAX) в MSSQL
          for (
            let i = Math.max(0, lineIndex - 2);
            i < Math.min(convertedLines.length, lineIndex + 3);
            i++
          ) {
            const mssqlLine = convertedLines[i];
            const varbinaryRegex = /\bVARBINARY\s*\(\s*MAX\s*\)/gi;
            const varbinaryMatch = varbinaryRegex.exec(mssqlLine);

            if (varbinaryMatch) {
              differences.push({
                type: "datatype",
                originalWord: "BLOB",
                convertedWord: "VARBINARY(MAX)",
                description: "Binary type (MySQL → SQL Server)",
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: i,
                convertedPosition: varbinaryMatch.index,
                equivalent: "VARBINARY(MAX)",
              });
              break;
            }
          }
        }
      }

      // Ищем ENGINE, CHARSET, COLLATE - не поддерживаются в MSSQL
      const unsupportedKeywords = [
        { regex: /\bENGINE\b/gi, name: "ENGINE", desc: "ENGINE clause" },
        { regex: /\bCHARSET\b/gi, name: "CHARSET", desc: "CHARSET clause" },
        { regex: /\bCOLLATE\b/gi, name: "COLLATE", desc: "COLLATE clause" },
        {
          regex: /\bUNSIGNED\b/gi,
          name: "UNSIGNED",
          desc: "UNSIGNED modifier",
        },
        {
          regex: /\bZEROFILL\b/gi,
          name: "ZEROFILL",
          desc: "ZEROFILL modifier",
        },
        { regex: /\bYEAR\b/gi, name: "YEAR", desc: "YEAR type" },
        { regex: /\bENUM\b/gi, name: "ENUM", desc: "ENUM type" },
        { regex: /\bSET\b/gi, name: "SET", desc: "SET type" },
      ];

      unsupportedKeywords.forEach(({ regex, name, desc }) => {
        while ((match = regex.exec(line)) !== null) {
          const position = match.index;

          // Для типов данных проверяем контекст
          if (["YEAR", "ENUM", "SET"].includes(name)) {
            if (isDataTypeInContext(line, position, name)) {
              differences.push({
                type: "removed",
                originalWord: name,
                convertedWord: "",
                description: `❌ ${desc} removed (not supported in SQL Server)`,
                originalLine: lineIndex,
                originalPosition: position,
                convertedLine: -1,
                convertedPosition: -1,
                equivalent: "",
              });
            }
          } else {
            // Для других ключевых слов принимаем в любом контексте
            differences.push({
              type: "removed",
              originalWord: name,
              convertedWord: "",
              description: `❌ ${desc} removed (not supported in SQL Server)`,
              originalLine: lineIndex,
              originalPosition: position,
              convertedLine: -1,
              convertedPosition: -1,
              equivalent: "",
            });
          }
        }
      });
    });
  }
};
// Функция для поиска добавленных комментариев
const findAddedComments = (
  originalLines: string[],
  convertedLines: string[],
  fromDialect: string,
  toDialect: string,
  differences: SQLDifference[]
) => {
  // Для SQLite ищем добавленные комментарии о FOREIGN KEY
  if (fromDialect === "mysql" && toDialect === "sqlite") {
    convertedLines.forEach((line, lineIndex) => {
      // Ищем комментарии о FOREIGN KEY
      const foreignKeyCommentRegex =
        /-- SQLite requires PRAGMA foreign_keys = ON for FK support/i;
      const pragmaRegex = /PRAGMA foreign_keys = ON;/i;

      if (foreignKeyCommentRegex.test(line)) {
        // Находим позицию комментария
        const match = foreignKeyCommentRegex.exec(line);
        if (match) {
          differences.push({
            type: "added",
            originalWord: "",
            convertedWord: line.trim(),
            description: "⚠️ Added comment about SQLite foreign key support",
            originalLine: -1,
            originalPosition: -1,
            convertedLine: lineIndex,
            convertedPosition: match.index,
            equivalent: "",
          });
        }
      }

      if (pragmaRegex.test(line)) {
        // Находим позицию PRAGMA
        const match = pragmaRegex.exec(line);
        if (match) {
          differences.push({
            type: "added",
            originalWord: "",
            convertedWord: line.trim(),
            description: "⚠️ Added PRAGMA for SQLite foreign key support",
            originalLine: -1,
            originalPosition: -1,
            convertedLine: lineIndex,
            convertedPosition: match.index,
            equivalent: "",
          });
        }
      }
    });
  }
};
// Быстрый анализ SQL
export const quickAnalyzeSQL = (sql: string) => {
  const lines = sql.split("\n").filter((line) => line.trim());
  const words = sql.split(/\s+/).filter((word) => word.trim());

  const upperSQL = sql.toUpperCase();
  let sqlType = "Unknown";

  if (upperSQL.includes("CREATE TABLE")) sqlType = "Table Definition";
  else if (upperSQL.includes("SELECT")) sqlType = "Query";
  else if (upperSQL.includes("INSERT")) sqlType = "Insert";
  else if (upperSQL.includes("UPDATE")) sqlType = "Update";
  else if (upperSQL.includes("DELETE")) sqlType = "Delete";
  else if (upperSQL.includes("CREATE VIEW")) sqlType = "View";
  else if (
    upperSQL.includes("CREATE PROCEDURE") ||
    upperSQL.includes("CREATE FUNCTION")
  )
    sqlType = "Stored Routine";

  const features = {
    hasCTE:
      upperSQL.includes("WITH") &&
      upperSQL.includes("AS") &&
      upperSQL.includes("SELECT"),
    hasWindowFunctions:
      /\b(ROW_NUMBER|RANK|DENSE_RANK|NTILE|LAG|LEAD)\s*\(.*OVER\s*\(/i.test(
        sql
      ),
    hasTransactions: /\b(BEGIN|COMMIT|ROLLBACK|START TRANSACTION)\b/i.test(sql),
    hasJoins: /\b(JOIN|LEFT JOIN|RIGHT JOIN|INNER JOIN|OUTER JOIN)\b/i.test(
      sql
    ),
    hasSubqueries: /\(SELECT\s+.+\s+\)/.test(sql),
  };

  return {
    lines: lines.length,
    words: words.length,
    type: sqlType,
    features,
    estimatedComplexity: Object.values(features).filter(Boolean).length,
  };
};

// diff.ts - обновляем filterDuplicates
const filterDuplicates = (differences: SQLDifference[]): SQLDifference[] => {
  const seen = new Set<string>();
  const filtered: SQLDifference[] = [];

  differences.forEach((diff) => {
    // Создаем уникальный ключ на основе позиции и слова
    const key = `${diff.type}|${diff.originalWord}|${diff.convertedWord}|${diff.originalLine}|${diff.originalPosition}`;

    if (seen.has(key)) return;

    // Фильтруем пустые
    if (!diff.originalWord && !diff.convertedWord) return;

    // НЕ фильтруем INT -> INTEGER и TIMESTAMP -> TIMESTAMPTZ
    const isImportantConversion =
      (diff.originalWord?.toUpperCase() === "INT" &&
        diff.convertedWord?.toUpperCase() === "INTEGER") ||
      (diff.originalWord?.toUpperCase() === "TIMESTAMP" &&
        diff.convertedWord?.toUpperCase() === "TIMESTAMPTZ") ||
      (diff.originalWord?.toUpperCase() === "DATETIME" &&
        diff.convertedWord?.toUpperCase() === "TIMESTAMP");

    // Фильтруем CURRENT_TIMESTAMP -> CURRENT_TIMESTAMP (без изменений)
    if (
      diff.originalWord?.toUpperCase() === "CURRENT_TIMESTAMP" &&
      diff.convertedWord?.toUpperCase() === "CURRENT_TIMESTAMP"
    ) {
      return;
    }

    if (!isImportantConversion) {
      // Фильтруем одинаковые слова (без реальной конвертации)
      if (
        diff.originalWord &&
        diff.convertedWord &&
        diff.originalWord.toUpperCase() === diff.convertedWord.toUpperCase()
      ) {
        return;
      }
    }

    seen.add(key);
    filtered.push(diff);
  });

  // Сортируем по строке и позиции для удобства
  return filtered.sort((a, b) => {
    if (a.originalLine !== b.originalLine) {
      return a.originalLine - b.originalLine;
    }
    return a.originalPosition - b.originalPosition;
  });
};


