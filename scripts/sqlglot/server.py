# ==================== –ò–ú–ü–û–†–¢–´ ====================

import sys
import json
import re  
from typing import List, Dict, Any

# ==================== –ö–û–ù–°–¢–ê–ù–¢–´ ====================

DIALECT_NOTES = {
    "snowflake": "Snowflake: No FOREIGN KEY enforcement, AUTOINCREMENT for auto-increment, NUMBER for numeric types",
    "bigquery": "BigQuery: No FOREIGN KEY support, STRING instead of VARCHAR, NUMERIC for decimals",
    "oracle": "Oracle: Use SEQUENCES or GENERATED AS IDENTITY for auto-increment, VARCHAR2 instead of VARCHAR",
    "postgres": "PostgreSQL: GENERATED BY DEFAULT AS IDENTITY for auto-increment, TIMESTAMPTZ for timestamps",
    "mssql": "SQL Server: IDENTITY for auto-increment, DATETIME2 for timestamps, [] for identifiers",
    "sqlite": "SQLite: TEXT for strings and dates, REAL for decimals, AUTOINCREMENT for auto-increment",
    "redshift": "Redshift: Based on PostgreSQL, IDENTITY for auto-increment, limited FOREIGN KEY",
    "mysql": "MySQL: Standard syntax with AUTO_INCREMENT"
}

# ==================== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ====================

def get_indent(line: str) -> int:
    """–ü–æ–ª—É—á–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –æ—Ç—Å—Ç—É–ø–∞ —Å—Ç—Ä–æ–∫–∏"""
    return len(line) - len(line.lstrip())

def split_columns(sql_part: str) -> List[str]:
    """–†–∞–∑–±–∏–≤–∞–µ—Ç —á–∞—Å—Ç—å SQL —Å –∫–æ–ª–æ–Ω–∫–∞–º–∏ –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –∫–æ–ª–æ–Ω–∫–∏"""
    columns = []
    current = []
    depth = 0
    
    for char in sql_part:
        if char == '(':
            depth += 1
        elif char == ')':
            depth -= 1
        
        if char == ',' and depth == 0:
            columns.append(''.join(current).strip())
            current = []
        else:
            current.append(char)
    
    if current:
        columns.append(''.join(current).strip())
    
    return columns

# ==================== –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∑–∞–º–µ–Ω ====================

def apply_dialect_conversion(sql: str, dialect: str) -> str:
    """–ü—Ä–∏–º–µ–Ω—è–µ—Ç –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –¥–∏–∞–ª–µ–∫—Ç–∞"""
    result = sql
    
    # –û–±—â–∏–µ –∑–∞–º–µ–Ω—ã –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    result = re.sub(r'\(\s+', '(', result)
    result = re.sub(r'\s+\)', ')', result)
    result = re.sub(r',\s+', ', ', result)
    result = re.sub(r'\s+', ' ', result)
    
    if dialect == "postgres":
        result = re.sub(r'\bAUTO_INCREMENT\b', 'GENERATED BY DEFAULT AS IDENTITY', result, flags=re.IGNORECASE)
        result = re.sub(r'\bINT\b', 'INTEGER', result, flags=re.IGNORECASE)
        result = re.sub(r'\bTIMESTAMP\b', 'TIMESTAMPTZ', result, flags=re.IGNORECASE)
        result = re.sub(r'`([^`]+)`', r'"\1"', result)
        result = re.sub(r'DECIMAL\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)', r'DECIMAL(\1,\2)', result, flags=re.IGNORECASE)
        result = re.sub(r'PRIMARY KEY\s+GENERATED BY DEFAULT AS IDENTITY', 
                       r'GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY', result, flags=re.IGNORECASE)
        
    elif dialect == "snowflake":
        result = re.sub(r'\bAUTO_INCREMENT\b', 'AUTOINCREMENT', result, flags=re.IGNORECASE)
        result = re.sub(r'\bINT\b', 'NUMBER', result, flags=re.IGNORECASE)
        result = re.sub(r'\bDECIMAL\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)', r'NUMBER(\1,\2)', result, flags=re.IGNORECASE)
        result = re.sub(r'\bTIMESTAMP\b', 'TIMESTAMP', result, flags=re.IGNORECASE)
        result = re.sub(r'DEFAULT CURRENT_TIMESTAMP(?!\()', 'DEFAULT CURRENT_TIMESTAMP()', result, flags=re.IGNORECASE)
        
    elif dialect == "bigquery":
        result = re.sub(r'\bAUTO_INCREMENT\b', '', result, flags=re.IGNORECASE)
        result = re.sub(r'\bINT\b', 'INT64', result, flags=re.IGNORECASE)
        # BigQuery STRING –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –≤ —Å–∫–æ–±–∫–∞—Ö
        result = re.sub(r'\bSTRING\s*\(\s*\d+\s*\)', 'STRING', result, flags=re.IGNORECASE)
        result = re.sub(r'\bVARCHAR\s*\(\s*(\d+)\s*\)', r'STRING', result, flags=re.IGNORECASE)
        result = re.sub(r'\bDECIMAL\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)', r'NUMERIC(\1,\2)', result, flags=re.IGNORECASE)
        result = re.sub(r'\bTIMESTAMP\b', 'TIMESTAMP', result, flags=re.IGNORECASE)
        result = re.sub(r'DEFAULT CURRENT_TIMESTAMP(?!\()', 'DEFAULT CURRENT_TIMESTAMP()', result, flags=re.IGNORECASE)
        
        # –£–±–∏—Ä–∞–µ–º FOREIGN KEY –¥–ª—è BigQuery
        result = re.sub(r',?\s*FOREIGN KEY\s*\([^)]+\)\s*REFERENCES\s*\w+\s*\([^)]+\)(\s*ON DELETE\s+\w+)?', 
                       '', result, flags=re.IGNORECASE)
        
        # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –∑–∞–ø—è—Ç—ã–µ –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è FOREIGN KEY
        result = re.sub(r',\s*,', ',', result)
        result = re.sub(r'\(\s*,', '(', result)
        result = re.sub(r',\s*\)', ')', result)
        
    elif dialect == "oracle":
        result = re.sub(r'\bAUTO_INCREMENT\b', '', result, flags=re.IGNORECASE)
        result = re.sub(r'\bINT\b', 'NUMBER(10)', result, flags=re.IGNORECASE)
        result = re.sub(r'\bVARCHAR\s*\(\s*', 'VARCHAR2(', result, flags=re.IGNORECASE)
        result = re.sub(r'\bDECIMAL\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)', r'NUMBER(\1,\2)', result, flags=re.IGNORECASE)
        result = re.sub(r'\bTIMESTAMP\b', 'TIMESTAMP WITH TIME ZONE', result, flags=re.IGNORECASE)
        result = re.sub(r'DEFAULT CURRENT_TIMESTAMP', 'DEFAULT SYSTIMESTAMP', result, flags=re.IGNORECASE)
        
    elif dialect == "mssql":
        result = re.sub(r'\bAUTO_INCREMENT\b', 'IDENTITY(1,1)', result, flags=re.IGNORECASE)
        result = re.sub(r'\bTIMESTAMP\b', 'DATETIME2', result, flags=re.IGNORECASE)
        result = re.sub(r'\bCURRENT_TIMESTAMP\b', 'GETDATE()', result, flags=re.IGNORECASE)
        result = re.sub(r'`([^`]+)`', r'[\1]', result)
        result = re.sub(r'IDENTITY\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)', r'IDENTITY(\1,\2)', result, flags=re.IGNORECASE)
        
    elif dialect == "sqlite":
        result = re.sub(r'\bAUTO_INCREMENT\b', 'AUTOINCREMENT', result, flags=re.IGNORECASE)
        result = re.sub(r'\bINT\b', 'INTEGER', result, flags=re.IGNORECASE)
        result = re.sub(r'\bVARCHAR\s*\(\s*(\d+)\s*\)', r'TEXT', result, flags=re.IGNORECASE)
        result = re.sub(r'\bDECIMAL\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)', r'REAL', result, flags=re.IGNORECASE)
        result = re.sub(r'\bTIMESTAMP\b', 'TEXT', result, flags=re.IGNORECASE)
        result = re.sub(r'\bDATE\b', 'TEXT', result, flags=re.IGNORECASE)
        
    elif dialect == "redshift":
        result = re.sub(r'\bAUTO_INCREMENT\b', 'IDENTITY(1,1)', result, flags=re.IGNORECASE)
        result = re.sub(r'\bINT\b', 'INTEGER', result, flags=re.IGNORECASE)
        result = re.sub(r'\bTIMESTAMP\b', 'TIMESTAMP', result, flags=re.IGNORECASE)
        result = re.sub(r'\bCURRENT_TIMESTAMP\b', 'GETDATE()', result, flags=re.IGNORECASE)
        result = re.sub(r'IDENTITY\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)', r'IDENTITY(\1,\2)', result, flags=re.IGNORECASE)
    
    return result

def format_create_table(sql: str, indent: int) -> List[str]:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç CREATE TABLE —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—ã"""
    lines = []
    
    # –ù–∞—Ö–æ–¥–∏–º –ø–æ–∑–∏—Ü–∏—é –æ—Ç–∫—Ä—ã–≤–∞—é—â–µ–π —Å–∫–æ–±–∫–∏
    open_paren = sql.find('(')
    if open_paren == -1:
        lines.append(' ' * indent + sql)
        return lines
    
    # –ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞: CREATE TABLE name (
    first_part = sql[:open_paren+1].strip()
    lines.append(' ' * indent + first_part)
    
    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–∫–æ–±–æ–∫
    content = sql[open_paren+1:sql.rfind(')')].strip()
    
    # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –∫–æ–ª–æ–Ω–∫–∏
    columns = split_columns(content)
    
    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –∫–æ–ª–æ–Ω–∫—É
    for i, column in enumerate(columns):
        column_line = ' ' * (indent + 4) + column.strip()
        if i < len(columns) - 1:
            column_line += ','
        lines.append(column_line)
    
    # –ó–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
    lines.append(' ' * indent + ');')
    
    return lines

def process_bigquery_result(sql: str) -> str:
    """–ü–æ—Å—Ç-–æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è BigQuery"""
    lines = sql.split('\n')
    new_lines = []
    in_create_table = False
    
    for line in lines:
        if 'CREATE TABLE' in line.upper():
            in_create_table = True
            new_lines.append(line)
        elif ');' in line:
            in_create_table = False
            new_lines.append(line)
        elif in_create_table and not line.strip():
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –≤–Ω—É—Ç—Ä–∏ CREATE TABLE
            continue
        elif 'FOREIGN KEY' in line.upper():
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Å FOREIGN KEY (–æ–Ω–∏ —É–∂–µ —É–¥–∞–ª–µ–Ω—ã)
            continue
        else:
            new_lines.append(line)
    
    return '\n'.join(new_lines)

def format_sql_with_original_structure(original_sql: str, dialect: str) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç SQL, —Å–æ—Ö—Ä–∞–Ω—è—è –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É"""
    lines = original_sql.split('\n')
    result_lines = []
    
    i = 0
    while i < len(lines):
        line = lines[i]
        stripped = line.strip()
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
        if not stripped or stripped.startswith('--'):
            result_lines.append(line)
            i += 1
            continue
        
        # –ï—Å–ª–∏ —ç—Ç–æ CREATE TABLE
        if stripped.startswith('CREATE TABLE'):
            table_block = []
            table_block.append(line)
            
            # –°–æ–±–∏—Ä–∞–µ–º –≤–µ—Å—å –±–ª–æ–∫ CREATE TABLE
            j = i + 1
            while j < len(lines):
                next_line = lines[j]
                table_block.append(next_line)
                if ';' in next_line:
                    break
                j += 1
            
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º –±–ª–æ–∫
            table_sql = ' '.join([l.strip() for l in table_block])
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é
            converted = apply_dialect_conversion(table_sql, dialect)
            # –†–∞–∑–±–∏–≤–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º
            formatted = format_create_table(converted, get_indent(line))
            result_lines.extend(formatted)
            
            i = j + 1
            continue
        
        # –ï—Å–ª–∏ —ç—Ç–æ SELECT - —Å–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        elif stripped.startswith('SELECT'):
            select_block = []
            select_block.append(line)
            
            # –°–æ–±–∏—Ä–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π SELECT –±–ª–æ–∫
            j = i
            while j < len(lines):
                if j > i:
                    select_block.append(lines[j])
                if lines[j].strip().endswith(';'):
                    break
                j += 1
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é –∫ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–µ –æ—Ç–¥–µ–ª—å–Ω–æ
            for select_line in select_block:
                if select_line.strip():
                    converted_line = apply_dialect_conversion(select_line.strip(), dialect)
                    result_lines.append(' ' * get_indent(select_line) + converted_line)
                else:
                    result_lines.append(select_line)
            
            i = j + 1
            continue
        
        # –î—Ä—É–≥–∏–µ SQL-–≤—ã—Ä–∞–∂–µ–Ω–∏—è
        else:
            converted = apply_dialect_conversion(stripped, dialect)
            result_lines.append(' ' * get_indent(line) + converted)
            i += 1
    
    return '\n'.join(result_lines)

# ==================== –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Ç—Ä–∞–Ω—Å–ø–∏–ª—è—Ü–∏–∏ ====================

def transpile_sql_for_dialect(sql: str, from_dialect: str, to_dialect: str) -> Dict[str, Any]:
    """–¢—Ä–∞–Ω—Å–ø–∏–ª—è—Ü–∏—è SQL —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –¥–∏–∞–ª–µ–∫—Ç–Ω—ã—Ö –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π"""
    try:
        warnings = []
        
        # –ü—Ä–æ—Å—Ç–∞—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        result = format_sql_with_original_structure(sql, to_dialect)
        
        # –î–∏–∞–ª–µ–∫—Ç-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –ø–æ—Å—Ç-–æ–±—Ä–∞–±–æ—Ç–∫–∏
        if to_dialect == "sqlite" and "FOREIGN KEY" in result.upper():
            if "PRAGMA foreign_keys = ON;" not in result:
                lines = result.split('\n')
                insert_idx = 0
                for idx, line in enumerate(lines):
                    if line.strip() and not line.strip().startswith('--'):
                        insert_idx = idx
                        break
                lines.insert(insert_idx, "-- SQLite requires PRAGMA foreign_keys = ON for FK support")
                lines.insert(insert_idx + 1, "PRAGMA foreign_keys = ON;")
                result = '\n'.join(lines)
        
        elif to_dialect == "bigquery":
            result = process_bigquery_result(result)
        
        return {
            "success": True,
            "transpiled": [result],
            "from_dialect": from_dialect,
            "to_dialect": to_dialect,
            "warnings": warnings,
            "note": DIALECT_NOTES.get(to_dialect, "Check dialect-specific documentation")
        }
        
    except Exception as e:
        fallback_sql = apply_dialect_conversion(sql, to_dialect)
            
        return {
            "success": False,
            "error": f"Transpilation failed: {str(e)}",
            "transpiled": [fallback_sql],
            "from_dialect": from_dialect,
            "to_dialect": to_dialect
        }

# ==================== Main Function ====================

def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    try:
        input_data = json.loads(sys.stdin.read())
        action = input_data.get('action', 'transpile')
        
        if action == 'transpile':
            result = transpile_sql_for_dialect(
                input_data.get('sql', ''),
                input_data.get('from_dialect', 'mysql'),
                input_data.get('to_dialect', 'postgres')
            )
                
        elif action == 'analyze':
            sql = input_data.get('sql', '')
            has_complex = any(keyword in sql.upper() for keyword in [
                'CREATE PROCEDURE', 'CREATE FUNCTION', 'CREATE TRIGGER', 'DELIMITER'
            ])
            
            result = {
                "success": True,
                "statements": len(sql.split(';')),
                "lines": len(sql.split('\n')),
                "has_complex_constructs": has_complex,
                "note": "Basic SQL analysis"
            }
            
        elif action == 'supported_dialects':
            result = {
                "success": True,
                "dialects": [
                    {"name": "mysql", "display_name": "MySQL", "icon": "üê¨"},
                    {"name": "postgres", "display_name": "PostgreSQL", "icon": "üêò"},
                    {"name": "snowflake", "display_name": "Snowflake", "icon": "‚ùÑÔ∏è"},
                    {"name": "bigquery", "display_name": "BigQuery", "icon": "‚òÅÔ∏è"},
                    {"name": "oracle", "display_name": "Oracle", "icon": "üî∑"},
                    {"name": "mssql", "display_name": "SQL Server", "icon": "üî∂"},
                    {"name": "sqlite", "display_name": "SQLite", "icon": "üì±"},
                    {"name": "redshift", "display_name": "Redshift", "icon": "üî¥"},
                ]
            }
        else:
            result = {"success": False, "error": f"Unknown action: {action}"}
        
        print(json.dumps(result, ensure_ascii=False))
        
    except Exception as e:
        print(json.dumps({
            "success": False,
            "error": f"Server error: {str(e)}"
        }, ensure_ascii=False))

if __name__ == "__main__":
    main()
